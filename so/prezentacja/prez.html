<html>
    <head>
        <meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
        <style type="text/css">
            h1 {
                FONT-FAMILY: Verdana, Arial, Helvetica, Sans-serif;
                FONT-SIZE: 24pt;
                LINE-HEIGHT: 200px;
                TEXT-ALIGN: center
            }
            h2 {
                FONT-FAMILY: Verdana, Arial, Helvetica, Sans-serif;
                FONT-SIZE: 18pt;
                LINE-HEIGHT: 50px;
                TEXT-ALIGN: center
            }
            h3 {
                FONT-FAMILY: Verdana, Arial, Helvetica, Sans-serif;
                FONT-SIZE: 16pt;
                LINE-HEIGHT: 30px;
                TEXT-ALIGN: center
            }
            h4 {
                FONT-FAMILY: Verdana, Arial, Helvetica, Sans-serif;
                FONT-SIZE: 13pt;
                LINE-HEIGHT: 20px;
                TEXT-ALIGN: center
            }
            p {
                FONT-FAMILY: Times New Roman, Serif, Roman, Gothic;
                FONT-SIZE: 12pt;
                TEXT-ALIGN: justify
            }
            table {
                FONT-FAMILY: Times New Roman, Serif, Roman, Gothic;
                FONT-SIZE: 12pt;
            }
            td {
                VERTICAL-ALIGN: top
            }
            ul {
                FONT-FAMILY: Times New Roman, Serif, Roman, Gothic;
                FONT-SIZE: 12pt;
            }
            ul.1 {
                FONT-SIZE: 12pt;
            }
            ol {
                FONT-FAMILY: Times New Roman, Serif, Roman, Gothic;
                FONT-SIZE: 12pt;
            }
            li {
                TEXT-ALIGN: justify;
            }
            pre {
                FONT-FAMILY: Courier New, Courier;
                FONT-SIZE: 11pt;
            }
            code {
                FONT-FAMILY: Courier New, Courier;
                FONT-SIZE: 11pt;
            }
            .pcode {
                FONT-FAMILY: Arial, Helvetica, Sans-serif;
                FONT-SIZE: 10pt;
            }
            .pcode.nl {
                COLOR: #666666;
                FONT-SIZE: 8pt
            }
            .path {
                FONT-FAMILY: Lucida console, Courier New, Courier;
                FONT-SIZE: 10pt;
            }                
            .auth {
                FONT-FAMILY: Verdana, Arial, Helvetica, Sans-serif;
                FONT-SIZE: 10pt;
                FONT-WEIGHT: bold;
                TEXT-ALIGN: center
            }
            .sig {
                COLOR: #aaaaaa;
                FONT-FAMILY: Verdana, Arial, Helvetica, Sans-serif;
                FONT-SIZE: 8pt;
                TEXT-ALIGN: right
            }
            .comment {
                FONT-FAMILY: Times New Roman, Serif, Roman, Gothic;
                FONT-SIZE: 10pt;
            }            
            a.toc {
                COLOR: #000066;
                FONT-FAMILY: Times New Roman, Serif, Roman, Gothic;
                FONT-SIZE: 12pt;
                TEXT-DECORATION: none
            }
            a.toc:hover {
                COLOR: #6666ff;
                TEXT-DECORATION: underline
            }
            a.toc2 {
                COLOR: #000066;
                FONT-FAMILY: Times New Roman, Serif, Roman, Gothic;
                FONT-SIZE: 11pt;
                TEXT-DECORATION: none
            }
            a.toc2:hover {
                COLOR: #6666ff;
                TEXT-DECORATION: underline
            }
            a.totoc {
                COLOR: #000066;
                FONT-FAMILY: Times New Roman, Serif, Roman, Gothic;
                FONT-SIZE: 8pt;
                TEXT-DECORATION: none
            }
            a.totoc:hover {
                COLOR: #6666ff;
                TEXT-DECORATION: underline
            }
        </style>
        <title>Zarz±dzanie procesami w Linux 2.4.7</title>
    </head>
    <body bgcolor="#ffffff">
        <h1>Zarz±dzanie procesami w Linux 2.4.7</h1>
        <div class="auth">
        Agnieszka Harasimczuk<br>
        Maciej Makowski<br>
        Hubert ¦led¼<br>
        Anna W³udarska
        </div><br><br><br>
        <hr noshade>
        <a name="toc"><h3>spis tre¶ci</h3>
        <ol>
            <li><a href="#struktury" class="toc">Wybrane struktury danych i funkcje do obs³ugi procesów</a>
                <ol>
                    <li><a href="#list_h" class="toc2">Standardowa implementacja list (list.h)</a>
                    <li><a href="#task_struct" class="toc2">Struktura task_struct</a>
                    <li><a href="#task_union" class="toc2">task_union</a>
                    <li><a href="#current" class="toc2">Makrodefinicja current</a>
                    <li><a href="#pidhash" class="toc2">Tablica pidhash</a>
                </ol>
            <li><a href="#run_queue" class="toc">Kolejka procesów gotowych</a>
                <ol>
                    <li><a href="#add_to_runqueue" class="toc2">Algorytm add_to_runqueue</a>
                    <li><a href="#del_from_runqueue" class="toc2">Algorytm del_from_runqueue</a>
                    <li><a href="#move_last_runqueue" class="toc2">Algorytm move_last_runqueue</a>
                    <li><a href="#move_first_runqueue" class="toc2">Algorytm move_first_runqueue</a>
                </ol>
            <li><a href="#wait_queue" class="toc">Kolejki procesów oczekuj±cych</a>
                <ol>
                    <li><a href="#add_wait_queue" class="toc2">Algorytm add_wait_queue</a>
                    <li><a href="#remove_wait_queue" class="toc2">Algorytm remove_wait_queue</a>
                </ol>
            <li><a href="#zmiany_stanu" class="toc">Zmiany stanu procesu</a>
                <ol>
                    <li><a href="#sleep_on" class="toc2">Algorytm sleep_on</a>
                    <li><a href="#try_to_wake_up" class="toc2">Algorytm try_to_wake_up</a>
                    <li><a href="#wake_up" class="toc2">Algorytm wake_up</a>
                </ol>
            <li><a href="#szeregowanie" class="toc">Szeregowanie procesów</a>
                <ol>
                    <li><a href="#typy_procesow" class="toc2">Typy procesów</a>
                    <li><a href="#klasy_procesow" class="toc2">Klasy procesów</a>
                    <li><a href="#polityki_szeregowania" class="toc2">Polityki szeregowania</a>
                    <li><a href="#wywolanie_schedule" class="toc2">Wywo³anie funkcji schedule</a>
                    <li><a href="#sd_szeregowania" class="toc2">Struktury danych zwi±zane z szeregowaniem</a>
                    <li><a href="#nice_to_ticks" class="toc2">Makro NICE_TO_TICKS</a>
                    <li><a href="#goodness" class="toc2">Funkcja goodness</a>
                    <li><a href="#dzialanie_szereg" class="toc2">Dzia³anie funkcji szereguj±cej</a>
                    <li><a href="#fun_sys_szereg" class="toc2">Funkcje systemowe zwi±zane z szeregowaniem</a>
                </ol>
            <li><a href="#synchro" class="toc">Synchronizacja procesów na poziomie j±dra</a>
                <ol>
                    <li><a href="#blokady" class="toc2">Blokady</a>
                    <li><a href="#up" class="toc2">Algorytm up</a>
                    <li><a href="#down" class="toc2">Aglorytm down</a>
                </ol>
            <li><a href="#switch" class="toc">Prze³±czanie kontekstu</a>
                <ol>
                    <li><a href="#switch_to" class="toc2">Makro switch_to</a>
                </ol>
            <li><a href="#exec" class="toc">Algorytm exec</a>
        </ol><br><br>

<!-- wybrane struktury danych i funkcje (AH) -->
        <hr noshade>
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#struktury" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="struktury"><h2>Wybrane struktury danych i funkcje do obs³ugi procesów</h2>
        <p>Aby zarz±dzaæ procesami j±dro musi mieæ pe³ne informacje na ich temat. Jest to zadanie deskryptora procesu, maj±cego strukturê typu <code>task_struct</code>, której pola zawieraj± informacje dotycz±ce jednego procesu.</p>

<!-- standardowa implementacja list (MM) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#list_h" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Maciej Makowski
                </td>
            </tr>
        </table>
        <a name="list_h"><h3>Standardowa implementacja list (list.h)</h3>
        <table width=100%><tr><td>
        <img src="res/list_h.jpg" align="right">
        <ul>
            <li>listy dwukierunkowe s± w Linuksie 2.4 implementowane przy pomocy struktur i operacji zdefiniowanych w <a class="path">Linux/include/linux/list.h</a><br><br><br>
            <li>podstawowa struktura:<br>
<pre>struct list_head {
        struct list_head *next, *prev;
};</pre><br>
            <li>wska¼nik do elementu listy uzyskiwany jest na podstawie wska¼nika do <code>list_head</code> i wiedzy o typie elementu (arytmetyka wska¼ników) przy pomocy makra <code>list_entry()</code><br><br><br>
            <li>dostêpne s± standardowe operacje na listach: 
                <ul class="1">
                    <li>sprawdzanie czy lista jest pusta (<code>list_empty()</code>)
                    <li>wstawianie elementu - na pocz±tek (<code>list_add()</code>) albo na koniec (<code>list_add_tail()</code>)
                    <li>usuwanie elementu (<code>list_del()</code>)
                    <li>³±czenie dwóch list (<code>list_splice()</code>)
                    <li>iteracja po elementach listy (<code>list_for_each()</code>)
                </ul>
        </ul>
        </td></tr></table>

<!-- struktura task_struct (AH) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#task_struct" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="task_struct"><h4>Struktura task_struct</h4>
        <img src="res/taskstruct.jpg" align="left">
        <p><code>struct task_struct *next_task, *prev_task</code> - pozwalaj± powi±zaæ wszystkie procesy w dwukierunkow± listê cykliczn±;<br><br>
        <code>unsigned long flags</code> - zmienna zawiera po³±czenie flag systemu:	
        <table border="0" cellpadding="1" cellspacing="0">
            <tr><td width="40">&nbsp;</td><td><code>PF_ALIGNWARN</code></td><td width="20">&nbsp;</td><td>/* jeszcze nie zaimplementowana */</td></tr>
            <tr><td width="40">&nbsp;</td><td><code>PF_STARTING</code></td><td width="20">&nbsp;</td><td>/* proces tworzony */</td></tr>
            <tr><td width="40">&nbsp;</td><td><code>PF_EXITING</code></td><td width="20">&nbsp;</td><td>/* proces koñczony */</td></tr>
            <tr><td width="40">&nbsp;</td><td><code>PF_FORKNOEXEC</code></td><td width="20">&nbsp;</td><td>/* proces potomny po operacji fork, jeszcze nie wykonywany */</td></tr>
            <tr><td width="40">&nbsp;</td><td><code>F_SUPERPRIV</code></td><td width="20">&nbsp;</td><td>/* proces ma uprawnienia super u¿ytkownika */</td></tr>
            <tr><td width="40">&nbsp;</td><td><code>PF_DUMPCORE</code></td><td width="20">&nbsp;</td><td>/* proces &quot;zrzuca&quot; obszar pamiêci */</td></tr>
            <tr><td width="40">&nbsp;</td><td><code>PF_SIGNALED</code></td><td width="20">&nbsp;</td><td>/* u¶miercony sygna³em */</td></tr>
            <tr><td width="40">&nbsp;</td><td><code>PF_MEMALLOC</code></td><td width="20">&nbsp;</td><td>/* proces w czasie alokacji pamiêci */</td></tr>
        </table><br>
        <code>struct mm_struct *mm</code> - wska¼niki do deskryptorów obszarów pamiêci<br><br>
        <code>int has_cpu, processor</code> - procesor, na jakim proces siê wykonuje<br><br>
        <code>unsigned long cpus_allowed</code> - informacja, na których procesorach proces mo¿e siê wykonywaæ<br><br>
        <code>struct linux_binfmt *binfmt</code> - dziêki tej zmiennej mo¿emy uruchamiaæ w Linuksie programy przez napisanie ich nazw<br><br>
        <code>/* identyfikator procesu */</code><br>
        <code>pid_t pid</code> - numer identyfikacyjny procesu<br>
        <code>pid_t pgrp</code> - numer identyfikacyjny grupy procesów<br>
        <code>pid_t session</code> - identyfikator sesji<br>
        <code>int leader</code> - warto¶æ mówi±ca, czy proces jest liderem grupy<br>
        <code>int ngroups</code> - ilo¶æ grup, do których nale¿y proces<br>
        <code>gid_t groups[NGROUPS]</code> - struktury opisuj±ce grupy, do których proces nale¿y<br><br>
        <code>struct task_struct *p_opptr, *p_pptr, *p_cptr, *p_ysptr, *p_osptr</code> - zmienne te pokazuj± na: 
        <table>
            <tr>    
                <td>
                    <table border="0" cellpadding="1" cellspacing="0">
                        <tr><td width="40">&nbsp;</td><td><code>*p_opptr</code></td><td width="20">&nbsp;</td><td>- oryginalnego rodzica</td></tr>
                        <tr><td width="40">&nbsp;</td><td><code>*p_pptr</code></td><td width="20">&nbsp;</td><td>- rodzica</td></tr>
                        <tr><td width="40">&nbsp;</td><td><code>*p_cptr</code></td><td width="20">&nbsp;</td><td>- najm³odszego potomka</td></tr>
                        <tr><td width="40">&nbsp;</td><td><code>*p_ysptr</code></td><td width="20">&nbsp;</td><td>- m³odszego brata</td></tr>
                        <tr><td width="40">&nbsp;</td><td><code>*p_osptr</code></td><td width="20">&nbsp;</td><td>- starszego brata</td></tr>
                    </table><br>
                </td>
                <td>
                    <img src="res/siblings.jpg">
                </td>
            </tr>
        </table>
        <code>unsigned long start_time</code> - moment, w którym proces zosta³ stworzony<br><br>
        <code>long per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS]</code> - tablice te przechowuj± informacje, ile czasu proces spêdzi³ odpowiednio w trybie u¿ytkownika i w trybie systemowym, na poszczególnych procesorach<br><br>
        <code>struct user_struct *user</code> - informacja o w³a¶cicielu<br>
        <code>struct tty_struct *tty</code> - terminal zwi±zany z procesem (je¿eli nie ma NULL)<br><br>
        <code>struct sem_undo *semundo</code> - informacja o zajmowanych semaforach<br><br>
        <code>/* szeregowanie */</code><br>
        <code>volatile long state</code> - stan, w jakim znajduje siê proces (-1 unrunnable, 0 runnable, >0 stopped)<br>
        <code>volatile long need_resched</code> - je¶li ta flaga jest ustawiona, oznacza to, ¿e potrzebne jest wykonanie przeszeregowania procesów - wywo³anie funkcji <code>schedule()</code>;<br>
        <code>long counter</code> - liczba tykniêæ zegara, które pozosta³y procesowi do zakoñczenia jego kwantu czasu; wywo³anie funkcji <code>update_process_times()</code> zmniejsza o jeden zawarto¶æ tego pola;<br>
        <code>long nice</code> - wp³ywa na d³ugo¶æ kwantu czasu przyznanego procesowi <a class="comment">(w starszych wersjach Linuksa jej rolê spe³nia³o priority)</a>; zmienia siê ona od -20 (najwy¿szy priorytet) do +19 (najni¿szy priorytet);<br>
        <code>unsigned long policy</code> - polityka szeregowania;<br>
        <code>unsigned long rt_priority</code> - statyczny priorytet procesów czasu rzeczywistego; przyjmuje warto¶ci od 0 (proces zwyk³y) do 99 (najwy¿szy priorytet);<br><br>
        <code>/* tablica pidhash */</code><br>
        <code>struct task_struct *pidhash_next</code> - wykorzystywane przez tablicê z hashowaniem<br>
        <code>struct task_struct **pidhash_pprev</code> - j.w.<br><br>
        <code>/* pliki */</code><br>
        <code>struct fs_struct *fs</code> - tu znajduj± siê dane zwi±zane z systemem plików<br>
        <code>struct files_struct *files</code> - informacje o plikach otwartych<br><br>
        <code>/* sygna³y */</code><br>
        <code>int exit_code, exit_signal</code> - kod zakoñczenia procesu i sygna³ wyj¶cia<br>
        <code>spinlock_t sigmask_lock</code> - ochrona i blokada sygna³ów<br>
        <code>struct signal_struct *sig</code> - wska¼nik do tablicy przechowuj±cej informacje na temat sposobu obs³ugi otrzymanych sygna³ów<br>
        <code>sigset_t blocked</code> - zawiera maski bitowe sygna³ów otrzymywanych, ale tych które s± obecnie zablokowane, wiêc trzeba bêdzie je obs³u¿yæ pó¼niej<br>
        </p><br><br>
        
<!-- Task_union (AH) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#task_union" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="Task_union"><h4>Task_union</h4>
        <p>Proces w trybie j±dra u¿ywa stosu zawartego w segmencie danych j±dra, który ró¿ni siê od stosu u¿ywanego w trybie u¿ytkownika. ¦cie¿ki wykonania j±dra rzadko u¿ywaj± tego stosu, wiêc 8KB jest wystarczaj±cym obszarem na stos i deskryptor procesu. Tak± strukturê wyra¿ono za pomoc± nastêpuj±cej unii:</p>
<pre>
union task_union {
	struct task_struct task;
	unsigned long stack[2048];
};
</pre>
        <p>Rejestr esp jest wska¼nikiem stosu u¿ywanym do okre¶lenia po³o¿enia wierzcho³ka stosu. W systemach Intela stos zaczyna siê na koñcu i rozszerza w kierunku pocz±tku obszaru pamiêci, gdzie znajduje siê deskryptor procesu. Zaraz po prze³±czeniu siê z trybu u¿ytkownika do trybu j±dra, stos j±dra procesu jest pusty i rejestr esp wskazuje na bajt znajduj±cy siê tu¿ za obszarem pamiêci.<br><br>
        <code>free_task_struct()</code> - Funkcja zwraca 8-kilobajtowe obszary pamiêci task_union i umieszcza je w pamiêci podrêcznej do czasu zape³nienia.<br><br>
        <code>alloc_task_struct()</code> - Funkcja ta alokuje obszary pamiêci dla <code>task_union</code> o wielko¶ci 8 KB. (Uwaga: Z powodu wydajno¶ci j±dro przechowuje te 8 KB jako dwa, znajduj±ce siê obok siebie bloki stronicowe, gdzie pierwsza strona jest wyrównana do wielokrotno¶ci 2<sup>13</sup>.)<br><br>
        <br><br>
        
<!-- makrodefinicja current (AH) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#current" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="current"><h4>Makrodefinicja current</h4>
        <p>J±dro mo¿e w prosty sposób okre¶liæ wska¼nik deskryptora procesu aktualnie wykonuj±cego siê na podstawie warto¶ci rejestru esp. (Obszar pamiêci ma 2<sup>13</sup> bajtów, wiêc wystarczy, ¿e j±dro zamaskuje 13 najmniej znacz±cych bitów esp).</p>
        <br><br>
        
<!-- tablica pidhash (AH) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#pidhash" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="pidhash"><h4>Tablica pidhash</h4>
        <p>Istniej± sytuacje, w których j±dro powinno mieæ mo¿liwo¶æ pobrania wska¼nika deskryptora na podstawie numeru pid (np. przy wywo³aniu funkcji systemowych zwi±zanych ze <code>schedule()</code>). W celu przyspieszenia przeszukiwania listy procesów i sprawdzania numerów pid w deskryptorach wprowadzono tablicê <code>pidhash</code>, która obecnie ma 1024 elementy. Pozycje tabeli zawieraj± wska¼niki do deskryptorów procesu. Pid jest t³umaczony na indeks tablicy za pomoc± nastêpuj±cego makra:<br><br>
        <code>#define pid_hashfn(x)	((((x) &gt;&gt; 8) ^ (x)) & (1023))</code><br><br>
        Zdarzaj± siê sytuacje, ¿e dwa numery daj± ten sam indeks w tablicy. W tym celu Linux u¿ywa ³añcuchów (ka¿da pozycja tabeli to dwustronna lista koliduj±cych procesów, zrealizowana za pomoc± <code>pidhash_next</code> i <code>pidhash_pprev</code> w deskryptorze procesu).<br> 
        Do wstawiania i usuwania procesów z tablicy s³u¿± funkcje: <code>hash_pid()</code> i <code>unhash_pid()</code>. Funkcja <code>find_task_by_pid()</code> zwraca wska¼nik deskryptora procesu o zadanym pid.
        <br><br>
        
<!-- kolejka procesów gotowych (MM) -->
        <hr noshade>
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#run_queue" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Maciej Makowski
                </td>
            </tr>
        </table>
        <a name="run_queue"><h2>Kolejka procesów gotowych</h2>
        <ul>
            <li>kolejka procesów gotowych zawiera procesy znajduj±ce siê w stanie <code>TASK_RUNNING</code> - niekoniecznie wszystkie takie, bo operacje ustawienia stanu procesu na <code>TASK_RUNNING</code> i wstawienia go do kolejki procesów gotowych nie s± wykonywane atomowo<br><br>
            <li>zaimplementowana jest w strukturze <code>task_struct</code> jako pole <code>run_list</code> typu <code>struct list_head</code><br><br>
            <li>proces <code>idle</code> nie jest umieszczany w kolejce procesów gotowych<br><br>
            <li>dostêp do pocz±tku kolejki mo¿na uzyskaæ za pomoc± zmiennej globalnej <code>runqueue_head</code> zadeklarowanej w pliku <a class="path">Linux/kernel/sched.c</a>
        </ul>
        <br><br>

<!-- algorytm add_to_runqueue (MM) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#add_to_runqueue" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Maciej Makowski
                </td>
            </tr>
        </table>
        <a name="add_to_runqueue"><h4>Algorytm add_to_runqueue</h4>
        <table border="0" class="pcode" cellpadding="0" cellspacing="0">
            <tr><td><b>¶rodowisko:</b></td><td>&nbsp;</td><td align="right"><code>nr_running</code></td><td>&nbsp;</td><td>- licznik aktywnych procesów</td></tr>
        </table><br>
<pre>
static inline void add_to_runqueue(struct task_struct * p)
{
        list_add(&p->run_list, &runqueue_head);
        nr_running++;
}
</pre>
        
<!-- algorytm del_from_runqueue (MM) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#del_from_runqueue" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Maciej Makowski
                </td>
            </tr>
        </table>
        <a name="del_from_runqueue"><h4>Algorytm del_from_runqueue</h4>
        <table border="0" class="pcode" cellpadding="0" cellspacing="0">
            <tr><td><b>¶rodowisko:</b></td><td>&nbsp;</td><td align="right"><code>nr_running</code></td><td>&nbsp;</td><td>- licznik aktywnych procesów</td></tr>
            <tr><td><b>&nbsp;</b></td><td>&nbsp;</td><td align="right"><code>jiffies</code></td><td>&nbsp;</td><td>- licznik liczby taktów, która up³ynê³a od startu systemu</td></tr>
        </table><br>
<pre>
static inline void del_from_runqueue(struct task_struct * p)
{
        nr_running--;
        p->sleep_time = jiffies;
        list_del(&p->run_list);
        p->run_list.next = NULL;
}
</pre>
        <ul>
            <li>warto¶æ pola <code>run_list.next</code> jest pó¼niej sprawdzana w celu ustalenia, czy proces znajduje siê w kolejce procesów gotowych
        </ul>
        
<!-- algorytm move_last_runqueue (MM) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#move_last_runqueue" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Maciej Makowski
                </td>
            </tr>
        </table>
        <a name="move_last_runqueue"><h4>Algorytm move_last_runqueue</h4>
        <table border="0" class="pcode" cellpadding="0" cellspacing="0">
            <tr><td><b>¶rodowisko:</b></td><td>&nbsp;</td><td align="right"><code>runqueue_head</code></td><td>&nbsp;</td><td>- wska¼nik do pierwszego elementu kolejki procesów gotowych</td></tr>
        </table><br>
<pre>
static inline void move_last_runqueue(struct task_struct * p)
{
        list_del(&p->run_list);
        list_add_tail(&p->run_list, &runqueue_head);
}
</pre>
        
<!-- algorytm move_first_runqueue (MM) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#move_first_runqueue" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Maciej Makowski
                </td>
            </tr>
        </table>
        <a name="move_first_runqueue"><h4>Algorytm move_first_runqueue</h4>
        <table border="0" class="pcode" cellpadding="0" cellspacing="0">
            <tr><td><b>¶rodowisko:</b></td><td>&nbsp;</td><td align="right"><code>runqueue_head</code></td><td>&nbsp;</td><td>- wska¼nik do pierwszego elementu kolejki procesów gotowych</td></tr>
        </table><br>
<pre>
static inline void move_first_runqueue(struct task_struct * p)
{
        list_del(&p->run_list);
        list_add(&p->run_list, &runqueue_head);
}
</pre>
        
<!-- kolejki procesów oczekuj±cych (MM) -->
        <hr noshade>
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#wait_queue" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Maciej Makowski
                </td>
            </tr>
        </table>
        <a name="wait_queue"><h2>Kolejki procesów oczekuj±cych</h2>
        <ul>
            <li>w kolejkach procesów oczekuj±cych umieszczane s± te procesy, które zostaj± wstrzymane w oczekiwaniu na zaj¶cie konkretnego zdarzenia - z ka¿dym takim zdarzeniem zwi±zana jest oddzielna kolejka<br><br>
            <li>element kolejki procesów oczekuj±cych zaimplementowany jest jako struktura <code>wait_queue_t</code> zawieraj±ca
                <ul class="1">
                    <li>wska¼nik do struktury <code>task_struct</code>
                    <li>strukturê <code>list_head</code>
                    <li>pole flag
                </ul><br><br>
            <li>istnieje specjalna struktura <code>wait_queue_head_t</code>, reprezentuj±ca g³owê kolejki, zawieraj±ca
                <ul class="1">
                    <li>strukturê <code>list_head</code>
                    <li>zamek kolejki, u¿ywany przy dodawaniu i usuwaniu elementów
                </ul><br><br>
            <li>jedyn± flag± zdefiniowan± dla elementu kolejki jest <code>WQ_FLAG_EXCLUSIVE</code><br><br>
        </ul>

<!-- algorytm add_wait_queue (MM) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#add_wait_queue" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Maciej Makowski
                </td>
            </tr>
        </table>
        <a name="add_wait_queue"><h4>Algorytm add_wait_queue</h4>
        <ul>
            <li>istniej± dwie wersjê <code>add_wait_queue()</code>:
                <ul class="1">
                    <li><code>add_wait_queue()</code> - wstawia element na pocz±tek kolejki bez ustawiania flagi <code>WQ_FLAG_EXCLUSIVE</code>
                    <li><code>add_wait_queue_exclusive()</code> - wstawia element na koniec kolejki ustawiaj±c flagê <code>WQ_FLAG_EXCLUSIVE</code>
                </ul><br><br>
            <li>schemat algorytmu:<br><br>
                <table border="0" class="pcode" cellpadding="0" cellspacing="0">
                    <tr><td><b>wej¶cie:</b></td><td>&nbsp;</td><td align="right"><code>q</code></td><td>&nbsp;</td><td>- kolejka procesów oczekuj±cych</td></tr>
                    <tr><td>&nbsp;</td><td>&nbsp;</td><td align="right"><code>wait</code></td><td>&nbsp;</td><td>- element kolejki, który ma zostaæ wstawiony</td></tr>
                </table><br>
                <ul class="1">
                    <li><code>add_wait_queue(q, wait):</code><br><br>
                        <table border="0" class="pcode" cellpadding="0" cellspacing="0">
                            <tr><td class="nl">1:</td><td>&nbsp;</td><td>wyzeruj flagê <code>WQ_FLAG_EXCLUSIVE</code> w <code>wait</code></td></tr>
                            <tr><td class="nl">2:</td><td>&nbsp;</td><td>wywo³aj <code>__add_wait_queue(q, wait)</code></td></tr>
                        </table><br>
                    <li><code>add_wait_queue_exclusive(q, wait)</code><br><br>
                        <table border="0" class="pcode" cellpadding="0" cellspacing="0">
                            <tr><td class="nl">1:</td><td>&nbsp;</td><td>ustaw flagê <code>WQ_FLAG_EXCLUSIVE</code> w <code>wait</code></td></tr>
                            <tr><td class="nl">2:</td><td>&nbsp;</td><td>wywo³aj <code>__add_wait_queue_tail(q, wait)</code></td></tr>
                        </table><br>
                 </ul>
            <li>wywo³ania operacji na kolejce procesów oczekuj±cych w liniach 2 odbywaj± siê przy zablokowanych przerwaniach<br><br>
            <li><code>__add_wait_queue()</code> i <code>__add_wait_queue_tail()</code> wywo³uj± odpowiednio <code>list_add()</code> i <code>list_add_tail()</code><br><br>
            <li>u¿ycie <code>add_wait_queue()</code> i <code>add_wait_queue_exclusive()</code> gwarantuje specyficzny uk³ad procesów w kolejce:<br><center><img src="res/wq.jpg"></center>
        </ul>

<!-- algorytm remove_wait_queue (MM) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#remove_wait_queue" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Maciej Makowski
                </td>
            </tr>
        </table>
        <a name="remove_wait_queue"><h4>Algorytm remove_wait_queue</h4>
        <ul>
            <li><code>remove_wait_queue()</code> sprowadza siê do wywo³ania (z wy³±czonymi przerwaniami) <code>__remove_wait_queue()</code>, które z kolei ogranicza siê do wywo³ania <code>list_del()</code>
        </ul>

<!-- zmiany stanu procesu (MM) -->
        <hr noshade>
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#zmiany_stanu" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Maciej Makowski
                </td>
            </tr>
        </table>
        <a name="zmiany_stanu"><h2>Zmiany stanu procesu</h2>
        <center><img src="res/stany.jpg"></center>
        <ul>
            <li><code><b>TASK_RUNNING</b></code> - proces wykonuje siê, albo czeka na wykonanie<br><br>
            <li><code><b>TASK_INTERRUPTIBLE</b></code> - proces wstrzymany w oczekiwaniu na zaj¶cie warunku (np. na zwolnienie siê zasobu). Mo¿e te¿ zostaæ obudzony przez przerwania sprzêtowe albo sygna³y<br><br>
            <li><code><b>TASK_UNINTERRUPTIBLE</b></code> - proces wstrzymany w oczekiwaniu na zaj¶cie warunku, sygna³y nie zmieniaj± jego stanu<br><br>
            <li><code><b>TASK_STOPPED</b></code> - proces zatrzymany na skutek otrzymania sygna³u <code>SIGSTOP</code>, <code>SIGTSTP</code>, <code>SIGTTIN</code> lub <code>SIGTTOU</code>, albo dowolnego sygna³u, je¶li jest monitorowany przez inny proces (np. przez debugger)<br><br>
            <li><code><b>TASK_ZOMBIE</b></code> - proces zakoñczy³ siê, ale jego rodzic nie wywo³a³ jeszcze funkcji <code>wait()</code>
        </ul>
        <br><br>

<!-- algorytm sleep_on (MM) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#sleep_on" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Maciej Makowski
                </td>
            </tr>
        </table>
        <a name="sleep_on"><h4>Algorytm sleep_on</h4>
        <ul>
            <li>s³u¿y do usypiania bie¿±cego procesu we wskazanej kolejce procesów oczekuj±cych<br><br>
            <li>istniej± cztery wersje <code>sleep_on()</code>:
                <ul class="1">
                    <li><code>sleep_on()</code> - usypia proces w stanie <code>TASK_UNINTERRUPTIBLE</code>
                    <li><code>interruptible_sleep_on()</code> - usypia proces w stanie <code>TASK_INTERRUPTIBLE</code>
                    <li><code>sleep_on_timeout()</code> - usypia proces w stanie <code>TASK_UNINTERRUPTIBLE</code> na okre¶lony w parametrze czas
                    <li><code>interruptible_sleep_on_timeout()</code> - usypia proces w stanie <code>TASK_INTERRUPTIBLE</code> na okre¶lony w parametrze czas
                </ul><br><br>
            <li>schemat algorytmu:<br><br>
                <table border="0" class="pcode" cellpadding="0" cellspacing="0">
                    <tr><td><b>wej¶cie:</b></td><td>&nbsp;</td><td align="right"><code>q</code></td><td>&nbsp;</td><td>- kolejka na której proces ma zasn±æ</td></tr>
                    <tr><td><b>¶rodowisko:</b></td><td>&nbsp;</td><td align="right"><code>current</code></td><td>&nbsp;</td><td>- bie¿±cy proces (to jego usypiamy)</td></tr>
                </table><br>
                <table border="0" class="pcode" cellpadding="0" cellspacing="0">
                    <tr><td class="nl">1:</td><td>&nbsp;</td><td>zainicjalizuj <code>wait</code> - nowy element kolejki procesów oczekuj±cych wskazuj±cy na <code>current</code></td></tr>
                    <tr><td class="nl">2:</td><td>&nbsp;</td><td>ustaw stan aktualnego procesu</td></tr>
                    <tr><td class="nl">3:</td><td>&nbsp;</td><td>wywo³aj <code>__add_wait_queue(q, wait)</code></td></tr>
                    <tr><td class="nl">4:</td><td>&nbsp;</td><td>wywo³aj odpowiedni± wersjê <code>schedule()</code></td></tr>
                    <tr><td class="nl">5:</td><td>&nbsp;</td><td>wywo³aj <code>__remove_wait_queue(q, wait)</code></td></tr>
                </table><br>
            <li>stan ustawiany w linii 2 zale¿y od tego, czy wo³amy wersjê <code>interruptible_</code>, czy nie<br><br>
            <li>wersja schedule w linii 4 zale¿y od tego, czy wo³amy wersjê <code>_timeout</code>, czy nie. W pierwszym wypadku wywo³ana zostanie funkcja <code>schedule_timeout()</code>, w drugim <code>schedule()</code><br><br>
            <li>wywo³ania operacji na kolejce procesów oczekuj±cych w liniach 3 i 5 odbywaj± siê przy zablokowanych przerwaniach<br><br>
            <li><code>__add_wait_queue()</code> i <code>__remove_wait_queue()</code> wywo³uj± odpowiednio <code>list_add()</code> i <code>list_del()</code>;<br>
                uwaga: wykorzystane zosta³y funkcje "wewnêtrzne", nie <code>add_wait_queue()</code> i <code>remove_wait_queue()</code><br><br>
            <li>proces u¶piony przy u¿yciu <code>sleep_on()</code> umieszczany jest na pocz±tku kolejki <code>q</code> i nie ma ustawionej flagi <code>WQ_FLAG_EXCLUSIVE</code>
        </ul>
        <br>

<!-- algorytm try_to_wake_up (MM) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#try_to_wake_up" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Maciej Makowski
                </td>
            </tr>
        </table>
        <a name="try_to_wake_up"><h4>Algorytm try_to_wake_up</h4>
        <ul>
            <li>s³u¿y do budzenia wskazanego procesu<br><br>
            <li><code>try_to_wake_up(p, synchronous)</code> ustawia stan procesu <code>p</code> na <code>TASK_RUNNING</code>, wstawia <code>p</code> do kolejki procesów gotowych (o ile siê na niej jeszcze nie znajduje) i (w zale¿no¶ci od warto¶ci argumentu <code>synchronous</code>) wywo³uje <code>reschedule_idle(p)</code><br><br>
            <li>zwraca <code>0</code> je¶li <code>p</code> by³ ju¿ w kolejce procesów gotowych, <code>1</code> w przeciwnym przypadku<br><br>
            <li>schemat algorytmu:<br><br>
                <table border="0" class="pcode" cellpadding="0" cellspacing="0">
                    <tr><td><b>wej¶cie:</b></td><td>&nbsp;</td><td align="right"><code>p</code></td><td>&nbsp;</td><td>- proces do obudzenia</td></tr>
                    <tr><td>&nbsp;</td><td>&nbsp;</td><td align="right"><code>synchronous</code></td><td>&nbsp;</td><td>- tryb synchroniczny/asynchroniczny</td></tr>
                </table><br>
                <table border="0" class="pcode" cellpadding="0" cellspacing="0">
                    <tr><td class="nl">1:</td><td>&nbsp;</td><td>ustaw stan <code>p</code> na <code>TASK_RUNNING</code></td></tr>
                    <tr><td class="nl">2:</td><td>&nbsp;</td><td><b>je¶li</b> <code>p</code> znajduje siê w kolejce procesów gotowych</td></tr>
                    <tr><td class="nl">3:</td><td>&nbsp;</td><td>&nbsp;&nbsp;zwróæ <code>0</code></td></tr>
                    <tr><td class="nl">4:</td><td>&nbsp;</td><td><b>koniec je¶li</b></td></tr>
                    <tr><td class="nl">5:</td><td>&nbsp;</td><td>dodaj <code>p</code> do kolejki procesów gotowych</td></tr>
                    <tr><td class="nl">6:</td><td>&nbsp;</td><td><b>je¶li</b> (<code>synchronous == 0</code>) lub (<code>p</code> nie mo¿e siê wykonywaæ na nastêpnym z kolei procesorze)</td></tr>
                    <tr><td class="nl">7:</td><td>&nbsp;</td><td>&nbsp;&nbsp;wywo³aj <code>reschedule_idle(p)</code></td></tr>
                    <tr><td class="nl">8:</td><td>&nbsp;</td><td><b>koniec je¶li</b></td></tr>
                    <tr><td class="nl">9:</td><td>&nbsp;</td><td>zwróæ <code>1</code></td></tr>
                </table><br>
            <li>algorytm wykonuje siê przy wy³±czonych przerwaniach (zajêty zostaje zamek kolejki procesów gotowych)<br><br>
            <li>w konfiguracji jednoprocesorowej warunek drugi z linii 6 jest zawsze prawdziwy, w zwi±zku z czym <code>reschedule_idle(p)</code> jest zawsze wykonywane<br><br>
        </ul>
        <br><br>

        
<!-- algorytm wake_up (MM) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#wake_up" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Maciej Makowski
                </td>
            </tr>
        </table>
        <a name="wake_up"><h4>Algorytm wake_up</h4>
        <ul>
            <li>makra z rodziny <code>wake_up()</code> s³u¿± do budzenia procesów z zadanej kolejki<br><br>
            <li>istnieje 10 odmian <code>wake_up()</code>:
                <ul class="1">
                    <li><code>wake_up(q)</code>
                    <li><code>wake_up_nr(q, nr)</code>
                    <li><code>wake_up_all(q)</code>
                    <li><code>wake_up_sync(q)</code>
                    <li><code>wake_up_sync_nr(q, nr)</code>
                    <li><code>wake_up_interruptible(q)</code>
                    <li><code>wake_up_interruptible_nr(q, nr)</code>
                    <li><code>wake_up_interruptible_all(q)</code>
                    <li><code>wake_up_interruptible_sync(q)</code>
                    <li><code>wake_up_interruptible_sync_nr(q, nr)</code><br>
                        <a class="comment">w Linuksie 2.4.7 w tej makrodefinicji jest b³±d - brak parametru nr. Nie zosta³o to poprawione równie¿ w najnowszej wersji 2.4.13</a>
                </ul><br><br>
            <li>znaczenie sufiksów:<br><br>
                <ul class="1">
                    <li><code>_interruptible</code> - te wersje <code>wake_up()</code> budz± tylko procesy znajduj±ce siê w stanie <code>TASK_INTERRUPTIBLE</code>; pozosta³e budz± zarówno procesy w stanie <code>TASK_INTERRUPTIBLE</code> jak i <code>TASK_UNINTERRUPTIBLE</code><br><br>
                    <li><code>_all</code> - budzi wszystkie procesy (w odpowiednich stanach) bez wzglêdu na to, czy maj± ustawion± flagê <code>WQ_FLAG_EXCLUSIVE</code><br><br>
                    <li><code>_nr</code> - budzi wszystkie procesy bez ustawionej flagi <code>WQ_FLAG_EXCLUSIVE</code> oraz podan± jako drugi argument liczbê procesów z ustawion± t± flag±<br><br>
                    <li><code>_sync</code> - umo¿liwia obudzenie procesu bez dokonywania przeszeregowania (bez wywo³ywania <code>reschedule_idle()</code> na rzecz tego procesu) w systemach wieloprocesorowych<br><br>
                    <li>je¶li nie ma ani sufiksu <code>_all</code>, ani <code>_nr</code>, to budzone s± wszystkie procesy nie oznaczone flag± <code>WQ_FLAG_EXCLUSIVE</code> i dok³adnie jeden proces z ustawion± t± flag± (o ile istnieje)
                </ul><br><br>
            <li>wszystkie makra <code>wake_up()</code> sprowadzaj± siê do wywo³ania funkcji <code>__wake_up_common(q, mode, nr_exclusive, sync)</code> z odpowiednimi parametrami<br><br>
            <li>schemat algorytmu <code>__wake_up_common()</code>:<br><br>
                <table border="0" class="pcode" cellpadding="0" cellspacing="0">
                    <tr><td><b>wej¶cie:</b></td><td>&nbsp;</td><td align="right"><code>q</code></td><td>&nbsp;</td><td>- kolejka procesów oczekuj±cych</td></tr>
                    <tr><td>&nbsp;</td><td>&nbsp;</td><td align="right"><code>mode</code></td><td>&nbsp;</td><td>- stany procesów, które maj± byæ budzone</td></tr>
                    <tr><td>&nbsp;</td><td>&nbsp;</td><td align="right"><code>nr_exclusive</code></td><td>&nbsp;</td><td>- liczba procesów z ustawion± flag± <code>WQ_FLAG_EXCLUSIVE</code> do obudzenia</td></tr>
                    <tr><td>&nbsp;</td><td>&nbsp;</td><td align="right"><code>sync</code></td><td>&nbsp;</td><td>- tryb synchroniczny/asynchroniczny (argument dla <code>try_to_wake_up()</code>)</td></tr>
                </table><br>
                <table border="0" class="pcode" cellpadding="0" cellspacing="0">
                    <tr><td class="nl">1:</td><td>&nbsp;</td><td><b>powtarzaj</b> dla ka¿dego procesu <code>p</code> w kolejce <code>q</code></td></tr>
                    <tr><td class="nl">2:</td><td>&nbsp;</td><td>&nbsp;&nbsp;<b>je¶li</b> stan <code>p</code> zgadza siê z <code>mode</code></td></tr>
                    <tr><td class="nl">3:</td><td>&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;<b>je¶li</b> wywo³anie <code>try_to_wake_up(p, sync)</code> zwróci³o <code>1</code></td></tr>
                    <tr><td class="nl">4:</td><td>&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>je¶li</b> <code>p</code> ma ustawion± flagê <code>WQ_FLAG_EXCLUSIVE</code></td></tr>
                    <tr><td class="nl">5:</td><td>&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zmniejsz <code>nr_exclusive</code> o 1</td></tr>
                    <tr><td class="nl">6:</td><td>&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>je¶li</b> <code>nr_exclusive == 0</code></td></tr>
                    <tr><td class="nl">7:</td><td>&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zakoñcz</td></tr>
                    <tr><td class="nl">8:</td><td>&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>koniec je¶li</b></td></tr>
                    <tr><td class="nl">9:</td><td>&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>koniec je¶li</b><br></td></tr>
                    <tr><td class="nl">10:</td><td>&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;<b>koniec je¶li</b><br></td></tr>
                    <tr><td class="nl">11:</td><td>&nbsp;</td><td>&nbsp;&nbsp;<b>koniec je¶li</b><br></td></tr>
                    <tr><td class="nl">12:</td><td>&nbsp;</td><td><b>koniec powtarzaj</b><br></td></tr>
                </table><br>
            <li>w rzeczywistym kodzie linie 3 - 6 to jeden warunek logiczny (dziêki leniwemu wyliczaniu warto¶ci logicznych w C)<br><br>
            <li>proces budzony nie jest tu usuwany z <code>q</code> - usuwanie odbywa siê w <code>sleep_on()</code>
        </ul>
        <br><br>

<!-- szeregowanie procesów (AH) -->
        <hr noshade>
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#szeregowanie" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="szeregowanie"><h2>Szeregowanie procesów</h2>
        <p>Algorytm szereguj±cy dzieli czas procesora na epoki. Na pocz±tku ka¿dej z nich ka¿demu procesowi jest przypisany pewien kwant czasu. Proces w trakcie jednej epoki mo¿e mieæ dostêp do procesora wielokrotnie, dopóki nie skoñczy mu siê jego kwant. Przy ka¿dym tykniêciu zegara, bie¿±cemu procesowi odejmuje siê jedynkê od pozosta³ego kwantu czasu. Gdy ca³y kwant jest skoñczony proces jest wyw³aszczany. Epoka koñczy siê, gdy wszystkie procesy gotowe do dzia³ania maj± ju¿ wykorzystany swój czas, wtedy nastêpuje przeliczenie kwantów (dla ka¿dego procesu w systemie) i rozpoczêcie nowej epoki.</p>
        <br><br>
        
<!-- typy procesów (AH) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#typy_procesow" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="typy_procesow"><h4>Typy procesów</h4>
        <p>Ze wzglêdu na czas reakcji na okre¶lone zdarzenie, procesy mo¿na podzieliæ na nastêpuj±ce grupy:<br>
        <ul>
            <li><b>wsadowe</b><br>
                Nie wymagaj± wspó³pracy z u¿ytkownikiem - pracuj± w tle. Zwykle posiadaj± ni¿szy priorytet, powinny wiêc byæ os³abiane przez <code>schedule()</code>. Na przyk³ad: kompilatory, mechanizmy baz danych...<br><br>
            <li><b>interakcyjne</b><br>
                Wymagaj± wspó³pracy z u¿ytkownikiem. Rzadko korzystaj± z procesora, ale je¶li zajdzie taka potrzeba powinny byæ wzglêdnie szybko obudzone. Na przyk³ad: edytory tekstu, pow³oki...<br><br>
            <li><b>czasu rzeczywistego</b><br>
                Warunkiem ich poprawnego dzia³ania jest minimalny czas reakcji na zaistnia³e zdarzenie. Procesy te nie mog± byæ blokowane przez inne zadania. Niestety Linux nie jest ca³kowicie przystosowany do obs³ugi tego typu zadañ. Przyk³ad: programy s³u¿±ce do obs³ugi d¼wiêku, obrazu...<br>
        </ul></p>
        <br><br>

<!-- klasy procesów (AH) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#klasy_procesow" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="klasy_procesow"><h4>Klasy procesów</h4>
        <p>W systemie Linux s± zaimplementowane nastêpuj±ce klasy procesów:
        <ul>
            <li><b>idle</b><br>
                Jest to proces o numerze 0, tworzony bez udzia³u <code>fork()</code>, inicjalizowany makrodefinicjami <code>INIT_TASK</code>. Proces ten ca³y czas znajduje siê w stanie <code>TASK_RUNNING</code> i w przypadku, gdy nie ma nikogo chêtnego do pracy on otrzymuje procesor. Gdy tylko pojawia siê jakikolwiek gotowy proces idle jest wyw³aszczany.<br><br>
            <li><b>procesy zwyk³e</b><br>
                Do tej klasy zalicza siê wiêkszo¶æ procesów. Wiêkszo¶æ u¿ytkowników systemu ma prawo tworzyæ tylko procesy tej klasy (w przeciwnym przypadku ³atwo mog³oby dochodziæ do zag³odzenia procesów).<br>
                Procesy tej klasy s± znacznie ró¿nicowane w trakcie szeregowania, ich priorytety s± przeliczane dynamicznie, dziêki czemu system jest bardziej sprawiedliwy i zapobiega zag³odzeniu.<br><br>
            <li><b>procesy czasu rzeczywistego</b><br>
                Te procesy mo¿e tworzyæ tylko administrator systemu. Wymagaj± one natychmiastowej reakcji systemu, wiêc s± znacznie uprzywilejowane w stosunku do pozosta³ych procesów. Równie¿ w¶ród nich wystêpuje znaczne zró¿nicowanie priorytetów (jednak¿e priorytety s± statyczne).<br>
        </ul></p>
        <br><br>
        
<!-- polityki szeregowania (AH) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#polityki_szeregowania" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="polityki_szeregowania"><h4>Polityki szeregowania</h4>
        <p>J±dro Linuksa w wersji 2.4.7 <u>teoretycznie</u> implementuje trzy polityki szeregowania. Z czego dwie pierwsze dotycz± tylko procesów czasu rzeczywistego, natomiast trzecia procesów zwyk³ych:
        <ul>
            <li><b>SCHED_FIFO</b><br>
                Jest to najbardziej niesprawiedliwa polityka, gdy¿ proces, który zdoby³ procesor mo¿e trzymaæ go bardzo d³ugo. Na szczê¶cie w praktyce wygl±da to inaczej, gdy¿ procesy czêsto zg³aszaj± ¿±dania wej¶cia-wyj¶cia, oraz same rezygnuj± z procesora (u¿ywaj±c funkcji <code>sched_yield()</code> - niestety jest to tylko <u>teoria</u>, gdy¿ obecnie funkcja ta nie dzia³a poprawnie). Równie¿ proces o wy¿szym priorytecie (czyli musi to byæ proces czasu rzeczywistego), który przejdzie do stanu TASK_RUNNING odbierze mu procesor.<br><br>
            <li><b>SCHED_RR</b><br>
                W tym przypadku, <u>teoretycznie</u>, procesowi, któremu przyznano procesor jest odmierzany kwant czasu, po którego skoñczeniu proces jest wyw³aszczany i wstawiany na koniec kolejki procesów gotowych, ale ju¿ z nowym kwantem - dziêki czemu planista daje szansê innym procesom czasu rzeczywistego o tym samym priorytecie. Proces traci te¿ procesor w tych samych przypadkach, co w polityce SCHED_FIFO.<br>
                (Takie dzia³anie jest tylko teori±, gdy¿ w obecnej implementacji proces jest usuwany na koniec kolejki procesów gotowych, jednak¿e jednocze¶nie nie oddaje on procesora. Z tego te¿ wzglêdu procesy szeregowane t± polityk± nie s± lepsze od SCHED_FIFO, a nawet ich obs³uga jest bardziej kosztowna). <br><br>
                <i>Przyk³ad:</i><br>
                Za³ó¿my, ¿e w systemie pojawia³y siê kolejno, w pewnych odstêpach czasu, cztery procesy czasu rzeczywistego <b>R1</b>, <b>F</b>, <b>R2</b> i <b>R3</b>. Procesy <b>R1</b>, <b>R2</b> i <b>R3</b> s± szeregowane za pomoc± strategii SCHED_RR, natomiast proces <b>F</b> za pomoc± SCHED_FIFO.<br>
                W jakiej kolejno¶ci bêd± dzia³aæ teoretycznie te procesy (w tym momencie pomijamy szczegó³y dotycz±ce kwantów czasu)? <br>
                Najpierw procesor otrzyma proces <b>R1</b>, po pewnym czasie zostanie on wyw³aszczony i wstawiony na koniec kolejki, wtedy pracê rozpocznie <b>F</b>, który nie odda procesora, a¿ do momentu zakoñczenia pracy. Wówczas na zmianê pracowaæ bêd± procesy <b>R2</b>, <b>R3</b> i <b>R1</b>, a¿ do momentu zakoñczenia pracy przez ka¿dego z nich.<br><br>
            <li><b>SCHED_OTHER</b><br>
                W tym przypadku priorytet procesu jest dynamiczny, tzn. zmienia siê w czasie dzia³ania procesu. W trakcie jego przeliczania brane s± pod uwagê dodatkowe okoliczno¶ci (patrz funkcja <code>goodness()</code>). Proces szeregowany zgodnie z t± polityk± mo¿e straciæ procesor, je¿eli:
                <ul>
                    <li>Zg³osi ¿±danie wej¶cia-wyj¶cia
                    <li>Dobrowolnie odda procesor (funkcja <code>sched_yield()</code>)
                    <li>Zg³osi siê proces czasu rzeczywistego
                    <li>Zg³osi siê proces zwyk³y
                </ul>
        </ul></p>
        <br><br>    

<!-- wywo³anie funkcji schedule (AH) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#wywolanie_schedule" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="wywolanie_schedule"><h4>Wywo³anie funkcji schedule</h4>
        <p>Funkcja ta jest zasadnicz± czê¶ci± szeregowania procesów w systemie Linux. Jest ona wywo³ywana na dwa sposoby: bezpo¶rednio i po¶rednio.<br><br>
        <ul>
            <li>Wywo³anie bezpo¶rednie<br><br>
                Ka¿dorazowo planista jest wywo³ywany po zakoñczeniu procedury obs³ugi przerwania zegarowego (dzieje siê to w funkcji <code>ret_from_sys_call</code> w pliku entry.S). Tak¿e bezpo¶rednio w sytuacji, gdy zaistnieje potrzeba zablokowania aktualnego procesu w trybie natychmiastowym, gdy¿ wymagane przez niego zasoby nie s± dostêpne (Jest to z regu³y wykonywane przez przekroczenie czasu procesu - <code>schedule_timeout()</code>). Równie¿ funkcje <code>sleep_on()</code> oraz <code>interruptible_sleep_on()</code> wywo³uj± <code>schedule()</code>. Jednak¿e w pierwszym przypadku po odzyskaniu procesora jest sprawdzana dostêpno¶æ zasobów, a w drugim ju¿ nie.<br>
                Równie¿ wiele sterowników urz±dzeñ bezpo¶rednio wywo³uje omawian± funkcjê.<br><br>
            <li>Wywo³anie po¶rednie<br><br>
                Wywo³anie to polega na ustawieniu flagi <code>need_resched</code> aktywnego procesu. Jest to robione, gdy:
                <ul>
                    <li>Proces wykorzysta³ przyznany mu kwant czasu (warunek ten jest sprawdzany w funkcji <code>update_process_times()</code>)
                    <li>Obudzony proces ma wy¿szy priorytet od bie¿±cego. Sprawdza to funkcja <code>reschedule_idle()</code>
                    <li>Wykonywane jest wywo³anie systemowe <code>sched_setscheduler()</code> lub <code>sched_yield()</code>
                </ul>
        </ul></p>
        <br><br>

<!-- struktury danych zwi±zane z szeregowaniem (AH) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#sd_szeregowania" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="sd_szeregowania"><h4>Struktury danych zwi±zane z szeregowaniem</h4>
        <ul>
            <li>makro <code>current</code> - wska¼nik do procesu, który posiada procesor;
        </ul>
        <p>Pola struktury <code>task_struct</code>:
        <ul>
            <li><code>state</code> - stan, w jakim znajduje siê proces;<br><br>
            <li><code>need_resched</code> - je¶li ta flaga jest ustawiona, oznacza to, ¿e potrzebne jest wykonanie przeszeregowania procesów - wywo³anie funkcji <code>schedule()</code>;<br><br> 
            <li><code>policy</code> - polityka szeregowania;<br><br>
            <li><code>rt_priority</code> - statyczny priorytet procesów czasu rzeczywistego; przyjmuje warto¶ci od 0 (proces zwyk³y) do 99 (najwy¿szy priorytet);<br><br>
            <li><code>nice</code> - wp³ywa na d³ugo¶æ kwantu czasu przyznanego procesowi, zmienia siê ona od -20 (najwy¿szy priorytet) do +19 (najni¿szy priorytet);<br><br>
            <li><code>counter</code> - liczba tykniêæ zegara, które pozosta³y procesowi do zakoñczenia jego kwantu czasu; wywo³anie funkcji <code>update_process_times()</code> zmniejsza o jeden zawarto¶æ tego pola;
        </ul>
        <br><br>

<!-- makro NICE_TO_TICKS (AH) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#NICE_TO_TICKS" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="NICE_TO_TICKS"><h4>Makro NICE_TO_TICKS</h4>
        <p>Powy¿sze makro jest zdefiniowane w nastêpuj±cy sposób:<br><br>
        <code>#define NICE_TO_TICKS(nice)	(TICK_SCALE(20-(nice))+1)</code><br><br>
        Makro <code>TICK_SCALE</code> zale¿y od warto¶ci zmiennej HZ, gdzie HZ jest sta³±, zale¿n± od architektury komputera, okre¶laj±c± czêstotliwo¶æ przerwañ zegara. Dla architektury Intela i386 HZ wynosi 100. Z tego te¿ wzglêdu w naszym przypadku makro <code>TICK_SCALE(x)</code> jest zdefiniowane jako <code>x &gt;&gt; 2</code>. Z tego wynika, ¿e zwraca ono warto¶æ <code>((20-nice) &gt;&gt; 2) + 1</code>.<br><br>
        <i>Przyk³ad:</i></p>
        <ol>
            <li><br><i>Je¿eli proces ma warto¶æ nice ustawion± na -20, wtedy:<br>
                20-(-20)=40, w systemie binarnym: 101000. Nastêpnie 101000 &gt;&gt; 2 otrzymujemy: 001010 czyli 8+2=10. Jeszcze 10+1=11, czyli dla warto¶ci nice=-20 nasze makro zwróci warto¶æ 11.</i>
            <li><br><i>Je¿eli proces ma warto¶æ nice ustawion± na 0, wtedy:<br>
                20-(0)=20, w systemie binarnym: 010100. Nastêpnie 010100 &gt;&gt; 2 otrzymujemy: 000101 czyli 4+1=5. Jeszcze 5+1=6, czyli dla warto¶ci nice=0 nasze makro zwróci warto¶æ 6</i>
            <li><br><i>Je¿eli proces ma warto¶æ nice ustawion± na +19, wtedy:<br>
                20-(+19)=1, w systemie binarnym: 000001. Nastêpnie 000001 &gt;&gt; 2 otrzymujemy: 000000 czyli 0. Jeszcze 0+1=1, czyli dla warto¶ci nice=+19 nasze makro zwróci warto¶æ 1.</i>
        </ol>
        <p>St±d wniosek, ¿e <code>NICE_TO_TICKS</code> zwraca warto¶ci od +11 do +1.</p>
        <a class="comment">Ciekawostka:  W starszych wersjach Linuksa makro to nie wystêpowa³o, tak samo jak warto¶æ nice, w miejsce której by³o priority. W trakcie przeliczania dynamicznego priorytetu w schedule() dodawali¶my po prostu priority (zamiast NICE_TO_TICKS(nice)).</a>
        <br><br>
        
<!-- funkcja goodness (AH) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#goodness" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="goodness"><h4>Funkcja goodness</h4>
        <p>Funkcja decyduje jak po¿±dany jest proces. &quot;Wa¿no¶æ&quot; procesu zale¿y od jego typu: wsadowy, interakcyjny, czy czasu rzeczywistego oraz od aktualnego procesora.<br><br>
        <center>
        <table border="0">
            <tr valign="top">
                <td><img src="res/sched1.jpg"></td><td width="30">&nbsp;</td>
                <td><img src="res/sched2.jpg"></td><td width="30">&nbsp;</td>
                <td><img src="res/sched3.jpg"></td><td width="30">&nbsp;</td>
                <td><img src="res/sched4.jpg"></td>
            </tr>
        </table>
        </center>
        <ol>
            <li>Je¿eli proces ma ustawion± flagê SCHED_YIELD oznacza to, i¿ sam dobrowolnie zrezygnowa³ z procesora, z tego wzglêdu jego waga jest ustawiana na -1, co jest równoznaczne temu, i¿ ten proces na pewno nie otrzyma procesora.<br><br>
            <li>Je¿eli proces jest typu SCHED_OTHER i skoñczy³ ju¿ swój kwant czasu ustawiana jest mu waga = 0. Natomiast, gdy jego pole <code>counter</code> jest ró¿ne od 0, wag± staje siê warto¶æ tego pola. Jednak¿e w pewnych przypadkach <code>goodness()</code> jest bardziej przychylna dla danego procesu (dodatkowo zwiêksza jego wagê), tzn. wtedy, je¿eli proces pracowa³ poprzednio na tym procesorze, waga jego jest dodatkowo zwiêkszana o sta³± warto¶æ równ± PROC_CHANGE_PENALTY (ustawion± na sta³e na 15); lub te¿, je¿eli proces ma t± sam± przestrzeñ adresow± co bie¿±cy, jego waga jest zwiêkszana o 1. Na zakoñczenie do wagi dodawana jest warto¶æ (20 - <code>nice</code>). <br><br>
            <li>Je¿eli proces jest procesem czasu rzeczywistego jego wag± staje siê 1000 zwiêkszony o priorytet czasu rzeczywistego, czyli <code>rt_priority</code>.
        </ol></p>
        <p><i>Wnioski</i>: Waga dodatnia oznacza, ¿e proces jest dobrym kandydatem na otrzymanie procesora (im wy¿sza waga tym chêtniej przyznajemy CPU), natomiast waga zerowa, b±d¼ ujemna oznacza, ¿e proces nie mo¿e otrzymaæ procesora, gdy¿ nie ma na to odpowiednich warunków.
        </p><br><br>

<!-- dzia³anie funkcji szereguj±cej (AH) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#dzialanie_szereg" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="dzialanie_szereg"><h4>Dzia³anie funkcji szereguj±cej</h4>
        <p>Funkcja <code>schedule()</code> dzia³a wed³ug nastêpuj±cego algorytmu:</p>
        <ol>
            <li>Sprawdza, czy zosta³a wywo³ana podczas obs³ugi przerwania. Je¶li jest to prawd± wypisuje komunikat o b³êdzie i koñczy swoje dzia³anie. Takie wywo³anie jest powa¿nym zagro¿eniem dla systemu. W <code>schedule()</code> gwarantujemy, ¿e przerwania s± w³±czone. (Jednak¿e s± momenty, w których musimy je wy³±czyæ).<br><br>
            <li>Je¶li obecny proces jest procesem czasu rzeczywistego, szeregowanym wed³ug strategii Round Robin (RR), któremu skoñczy³ siê w³a¶nie kwant czasu, to przyznawany jest mu nowy (wyliczany z makra <code>NICE_TO_TICKS()</code>) oraz taki proces jest ustawiany na koñcu kolejki procesów gotowych.<br><br>
            <li>Je¶li obecny proces jest w stanie TASK_INTERRUPTIBLE <code>schedule()</code> sprawdza, czy nadszed³ nieblokowany sygna³, je¿eli tak zmienia mu stan na TASK_RUNNING.<br>
                Nastêpnie, je¿eli proces nie jest w stanie TASK_RUNNING usuwa go z kolejki procesów gotowych. Zeruje warto¶æ pola need_resched bie¿±cego procesu.<br><br>
            <li>Funkcja dokonuje wyboru najbardziej odpowiedniego procesu do przyznania mu procesora. Korzysta przy tym z funkcji <code>goodness()</code> opisanej powy¿ej. Wyboru dokonuje w kilku krokach.<br><br>
                Pierwszym z mo¿liwych kandydatów (który zawsze istnieje) jest proces <code>idle</code>. Jednak¿e otrzymuje on procesor tylko pod warunkiem, ¿e w danej chwili nikt inny nie jest gotowy do dzia³ania. Z tego te¿ wzglêdu jego &quot;wa¿no¶æ&quot; jest ustawiana na -1000 (Pozosta³e procesy otrzymuj± wy¿sz± wagê, co zapewnia poprawne dzia³anie).<br><br>
                Nastêpnie <code>schedule()</code> sprawdza, czy bie¿±cy proces, (pod warunkiem, ¿e jest w stanie TASK_RUNNING) móg³by otrzymaæ jeszcze raz procesor, (badane jest, czy dany proces mo¿e pracowaæ na tym procesorze poprzez sprawdzenie stanu jego pola <code>cpus_allowed</code> struktury <code>task_struct</code>), je¿eli tak - jest uznawany za lepszego kandydata ani¿eli <code>idle</code> i jest brany jako pierwszy pod uwagê (<code>schedule()</code> zapamiêtuje jego wagê). Dziêki tej operacji w przypadku, gdy kilka procesów dostanie najwy¿sz± warto¶æ - w tym tak¿e bie¿±cy, to jemu zostanie przyznany procesor.<br>
                Jednak¿e to rozwi±zanie jest w pewnych sytuacjach b³êdne i nie spe³nia przyjêtych wymogów. Dlaczego??? <a class="comment">(Patrz rozwi±zanie zadañ)</a><br><br>
                Teraz w celu znalezienia najlepszego pretendenta do pracy planista zaczyna przechodzenie kolejki procesów gotowych ka¿dorazowo od pocz±tku (zawsze najpierw sprawdza, czy dany proces mo¿e pracowaæ na danym procesorze). Przy czym stara siê zapamiêtaæ dotychczas najlepszego kandydata oraz jego wagê (przyznawan± przez <code>goodness()</code>. Waga kolejnych procesów jest porównywana z ostatnio zapamiêtan± warto¶ci±, je¿eli jest wy¿sza to oznacza, ze ten proces jest lepszym kandydatem do procesora). 
<pre>	
list_for_each(tmp, &runqueue_head) {
		p = list_entry(tmp, struct task_struct, run_list);
		if (can_schedule(p, this_cpu)) {
			int weight = goodness(p, this_cpu, prev-&gt;active_mm);
			if (weight &gt; c)
				c = weight, next = p;
		}
	}
</pre>
                Po przej¶ciu powy¿szej pêtli mog± wyst±piæ trzy ró¿ne sytuacje. Po pierwsze mo¿e siê okazaæ, ¿e znale¼li¶my proces, który powinien otrzymaæ CPU - czyli zapamiêtana warto¶æ jest dodatnia. Po drugie mo¿e ona mieæ warto¶æ -1000, co jest równoznaczne, ¿e ¿aden proces nie chce lub nie mo¿e dzia³aæ, wiêc proces jest przyznany <code>idle</code>. (<code>goodness()</code> zwraca warto¶æ 0 lub >0, dla ka¿dego prawid³owego procesu, czyli gdyby w naszej kolejce <code>runqueue</code>, by³ jaki¶ odpowiedni proces to pamiêtana warto¶æ by³aby nieujemna). I po trzecie mo¿e byæ sytuacja, w której najwy¿sz± warto¶ci± okaza³o siê zero - a to oznacza, ¿e wszystkie procesy skoñczy³y ju¿ swoje kwanty czasu. W tej sytuacji nale¿y przyznaæ wszystkim procesom nowe kwanty czasu (nie tylko tym z listy procesów bie¿±cych). W tym celu korzystamy z nastêpuj±cego algorytmu:
<pre>
    for_each_task(p)
            p-&gt;counter = (p-&gt;counter &gt;&gt; 1) + NICE_TO_TICKS(p-&gt;nice);
</pre>
                Czyli do przeliczenia priorytetów dynamicznych, potrzebna jest znajomo¶æ czasu, który pozosta³ procesowi (warto¶æ counter) z ostatniego przydzia³u oraz warto¶æ wyliczona z priorytetu bazowego przy pomocy makra NICE_TO_TICKS.<br>
                Interesuj±ce jest, ¿e przed przeliczeniem priorytetów dynamicznych <code>schedule()</code> zdejmuje blokadê z <code>runqueue</code>. Wydaje siê to trochê dziwne, jednak¿e trzeba zauwa¿yæ, ¿e przeliczeniu podlegaj± absolutnie wszystkie procesy, co mo¿e zaj±æ stosunkowo du¿o czasu, podczas gdy inny procesor móg³by chcieæ wywo³aæ funkcjê <code>schedule()</code>, w celu wybrania najlepszego procesu na ten procesor.<br><br>
                Po przeliczeniu priorytetów, <code>schedule()</code> wraca z powrotem na pocz±tek punktu 4. <br><br>
            <li>W tym momencie wiemy ju¿, który proces bêdzie dzia³a³ na tym procesorze, z tego te¿ wzglêdu ustawiamy zmienne struktury <code>task_struct: has_cpu</code> na 1 i <code>processor</code> na <code>this_cpu</code>. <br><br>
            <li>Przygotowanie do zamiany procesów - ustawianie odpowiednich zmiennych do <code>switch_to()</code>, prze³±czenie kontekstu.<br><br>
            <li>Wywo³anie funkcji <code>reschedule_idle()</code>, która to sprz±ta wszelkie pozosta³e, niepoustawiane znaczniki po schedulerze (np. wy³±cza flagê SCHED_YIELD, a w przypadku SMP ustawia pola dotycz±ce procesora). Funkcja ta w systemie wieloprocesorowym wywo³uje te¿ funkcjê <code>reschedule_idle()</code> (oczywi¶cie pod warunkiem, ¿e wyw³aszczony proces nie by³ procesem <code>idle</code>). <code>reschedule_idle()</code> jest bardzo wa¿n± funkcj± - czêsto jest wywo³ywana w celu ustawienia flagi <code>need_resched</code> (w systemie jednoprocesorowym dotyczy to przypadku, gdy proces, dla którego j± wywo³ano ma wiêkszy priorytet od bie¿±cego). W Linuksie SMP sprawdza, czy proces, któremu w³a¶nie odebrano procesor, nie móg³by wyw³aszczyæ kogo¶ z innego CPU.
        </ol>
        <center><img src="res/sched_gl.jpg"></center>
        <br><br>

<!-- funkcje systemowe zwi±zane z szeregowaniem (AH) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#fun_sys_szereg" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Agnieszka Harasimczuk
                </td>
            </tr>
        </table>
        <a name="fun_sys_szereg"><h4>Funkcje systemowe zwi±zane z szeregowaniem</h4>
        <p>Poni¿sze funkcje s³u¿± do zmiany priorytetów procesów i ich polityki szeregowania, oraz do odczytywania tych danych. Ka¿dy u¿ytkownik mo¿e dowolnie obni¿aæ priorytety swoich procesów, ale tylko administrator mo¿e tak¿e je podwy¿szaæ.</p>
        <ul>
            <li><code>nice(int increment)</code><br>
                Funkcja ta s³u¿y procesowi do zmiany jego priorytetu bazowego (<code>nice</code>). <code>Increment</code> mo¿e przyjmowaæ dowolne warto¶ci ca³kowite, ale je¿eli jest >+40, to zostaje obciête do +40, natomiast, gdy jest <-40 zostaje obciête do -40. Po wywo³aniu tej funkcji pole nice ma warto¶æ <code>(nice + increment)</code> (ale oczywi¶cie obcinamy to do zakresu -20...+19). Czyli im warto¶æ increment jest mniejsza, tym bardziej podwy¿szamy priorytet.<br><br>
            <li><code>sched_yield(void)</code><br>
                Proces, który wywo³uje t± funkcjê chce dobrowolnie oddaæ procesor, bez usypiania. Z tego te¿ wzglêdu, je¿eli nie jest jedynym, który mo¿e pracowaæ (tzn. istnieje jeszcze przynajmniej jeden proces na li¶cie <code>runqueue</code>, o stanie TASK_RUNNING, który nie pracuje na ¿adnym innym procesorze), ustawia znacznik <code>need_resched</code>, a w przypadku procesu zwyk³ego zaznacza równie¿, ¿e wywo³a³ t± funkcjê, tzn. ustawia w polu <code>policy</code> dodatkowo flagê SCHED_YIELD.<br>
                Uwaga!!! Teoretycznie funkcja powinna umo¿liwiaæ procesom czasu rzeczywistego dobrowoln± rezygnacjê z procesora. Jednak¿e nie spe³nia ona swojego zadania i taki proces, który wywo³a³ tê funkcjê nie zostaje jednak wyw³aszczony. <br><br>
            <li><code>sched_getscheduler(pid_t pid)</code><br>
                Funkcja zwraca informacjê o polityce szeregowania danego procesu.<br><br>
            <li><code>sched_setscheduler(pid_t pid, int policy, struct sched_param *param)</code><br>
                Funkcja pozwala ustawiæ dla podanego procesu jego politykê szeregowania oraz statyczny priorytet (<code>rt_priority</code>). Proces taki jest przenoszony na pocz±tek kolejki procesów gotowych i jest ustawiana flaga <code>need_resched</code>.<br><br>
            <li><code>sched_getparam(pid_t pid, struct sched_param *param)</code><br>
                Zwraca parametry szeregowania procesu (tylko warto¶æ pola <code>rt_priority</code>).<br><br>
            <li><code>sched_setparam(pid_t pid, struct sched_param *param)</code>
                Funkcja analogiczna do <code>sched_setscheduler()</code>, tylko nie zmienia priorytetu.<br><br>
            <li><code>sched_get_priority_min(int policy)</code><br>
                Funkcja zwraca maksymalny priorytet, jaki mo¿e mieæ proces o danej polityce szeregowania tzn.: w przypadku SCHED_RR oraz SCHED_FIFO = 99, SCHED_OTHER = 0.<br><br>
            <li><code>sched_get_priority_max(int policy)</code><br>
                Funkcja zwraca minimalny priorytet, jaki mo¿e mieæ proces o danej polityce szeregowania tzn.: w przypadku SCHED_RR oraz SCHED_FIFO = 1, SCHED_OTHER = 0.<br><br>
            <li><code>sched_rr_get_interval(pid_t pid, struct timespec *interval)</code><br>
                Wywo³anie systemowe zwraca przyznany kwant czasu dla danego procesu (warto¶æ zwracan± przez <code>NICE_TO_TICKS</code>) (innego ni¿ SCHED_FIFO - ten teoretycznie pracuje bez ograniczeñ).</br>
        </ul>
        <br><br>
        
<!-- synchronizacja procesów na poziomie j±dra (H¦) -->
        <hr noshade>
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#synchro" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Huber ¦led¼
                </td>
            </tr>
        </table>
        <a name="synchro"><h2>Synchronizacja procesów na poziomie j±dra</h2>
        <p>Jak wiadomo, funkcje j±dra s± wykonywane w nastêpstwie ¿±dañ, które mog± byæ zg³aszane na dwa sposoby:</p>
        <ul>
            <li>proces wykonuj±cy siê w trybie u¿ytkownika zg³asza jaki¶ wyj±tek
            <li>urz±dzenie zewnêtrzne wysy³a sygna³ do programowalnego kontrolera przerwañ PIC (ang. Programmable Interrupt Controller) za pomoc± linii IRQ, a odpowiednie przerwania s± w³±czone.
        </ul>
        <p>Sekwencja instrukcji, wykonywana w trybie j±dra w celu obs³u¿enia ¿±dania, jest nazywana <b>¶cie¿k± wykonania j±dra</b>.<br> 
        ¦cie¿ki wykonania j±dra pe³ni± rolê podobn± do procesów, s± jednak prostsze. Przede wszystkim nie jest z nimi zwi±zany ¿aden deskryptor, poza tym nie s± szeregowane za pomoc± jednej  funkcji, ale przez wstawienie do kodu j±dra sekwencji instrukcji zatrzymuj±cych lub wznawiaj±cych ¶cie¿ki.<br><br>
        W najlepszym przypadku procesor wykonuje ¶cie¿ki wykonania j±dra sekwencyjnie, od pierwszej do ostatniej instrukcji. Niestety, je¿eli siê zdarzy:</p>
        <ul>
            <li>prze³±czenie kontekstu;
            <li>wyst±pienie przerwania, akurat wtedy gdy procesor wykonywa³ jak±¶ ¶cie¿kê wykonania j±dra z w³±czonymi przerwaniami (w tym przypadku j±dro pozostawia  niedokoñczon± ¶cie¿kê wykonania j±dra i rozpoczyna nastêpn±, obs³uguj±c± przerwanie);
        </ul>
        <p>to procesor musi przeplataæ ¶cie¿ki  wykonania j±dra. I tutaj trzeba uwa¿aæ na struktury danych zawieraj±ce  kilka powi±zanych zmiennych. Wszystkie instrukcje operuj±ce na takiej strukturze trzeba umie¶ciæ w jednej sekcji krytycznej. </p><br>
        <p>W Linuksie s± wyró¿nione cztery techniki synchronizacji: 
        <ul>
            <li>niewyw³aszczanie procesów w trybie j±dra
            <li>operacje niepodzielne
            <li>wy³±czanie przerwañ
            <li>blokady
        </ul>
        <br><br><br><br><br><br><br><br>
                
<!-- blokady (H¦) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#blokady" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Huber ¦led¼
                </td>
            </tr>
        </table>
        <a name="blokady"><h4>Blokady</h4>
        <p>W systemach jednoprocesorowych Linux oferuje jeden rodzaj blokad, tzw. <b>semafory j±dra</b>.<br>
        W przypadku gdy ¶cie¿ka wykonania j±dra chce pobraæ zajêty, chroniony przez semafor j±dra, zasób, to odpowiedni proces zostanie u¶piony. Zacznie swoje dzia³anie wtedy, gdy zasób stanie siê dostêpny.<br><br>
        Semafory j±dra s± obiektami typu <code>struct semaphore</code> [<a class="path">Linux/include/asm-i386/semaphore.h</a>] i maj± nastêpuj±ce pola:</p>
        <ul>
            <li><code>atomic_t count</code> - przechowuje  warto¶æ  ca³kowit±. Je¿eli jest wiêksza ni¿ 0, oznacza to, ¿e zasób jest dostêpny. Je¿eli warto¶æ count jest mniejsza lub równa 0, to zasób jest zajêty. Zmienna typu <code>atomic_t</code> jest struktur± zawieraj±c± jeden atrybut typu <code>int</code>, na której w sposób atomowy s± zdefiniowane pewne operacje arytmetyczne.<br><br>
            <li><code>wait_queue_head_t wait</code> - przechowuje adres kolejki oczekiwania, która zawiera wszystkie u¶pione procesy, czekaj±ce aktualnie na zasób<br><br>
            <li><code>int sleepers</code> -  zmienna pomocnicza, która mówi ile procesów w danej chwili przejdzie pod semaforem. Jest ona inicjalizowana na  0.<br><br>
        </ul>
        <p>Pole count jest zwiêkszane, gdy proces chce podnie¶æ semafor, a zmniejszane gdy go opuszcza.<br><br>
        Je¿eli proces chce podnie¶æ semafor, wywo³uje funkcjê <code>up()</code>.</p>
        <br><br>

<!-- algorytm up (H¦) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#up" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Huber ¦led¼
                </td>
            </tr>
        </table>
        <a name="up"><h4>Algorytm up</h4>
        <p>Najpierw proces zwiêksza warto¶æ <code>count</code> i porównuje j± z zerem (porównanie i test s± wykonywane atomowo). Je¿eli nowa warto¶æ <code>count</code> jest wiêksza od zera, to w kolejce oczekiwania semafora nie ma ¿adnego procesu, tak wiêc proces nic wiêcej nie robi. W przeciwnym wypadku, <code>(count &lt;=0)</code> budzi pierwszy proces z kolejki procesów czekaj±cych na zasób (funkcja <code>wake_up()</code>).  Wykonanie funkcji <code>wake_up()</code> jest chronione, tzn. przed  wykorzystywaniem elementów kolejki zapamiêtywane s± flagi oraz wy³±czane przerwania, a  po zakoñczeniu dzia³añ na kolejce przerwania zostaj± w³±czane, a flagi odtwarzane.</p>
<pre> 
void up(semaphore *sem)
{
    /* Sekcja krytyczna */
    sem-&gt;count ++;
   
    if (sem-&gt;count &lt;= 0) /* wpp. kolejka oczekiwania jest pusta */
    {
        /* Koniec sekcji */

        Wstaw nastêpny proces z  kolejki oczekiwania semafora do kolejki procesów  gotowych. 
        /* Budzenie procesu - funkcja  wake_up */

    }
}
</pre>
        <p>Je¿eli proces chce opu¶ciæ semafor, wywo³uje funkcjê <code>down()</code>. </p>
        <br><br>
        
<!-- algorytm down (H¦) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#down" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Huber ¦led¼
                </td>
            </tr>
        </table>
        <a name="down"><h4>Algorytm down</h4>
        <p>Analogicznie jak w funkcji <code>up()</code>, na pocz±tku proces zmniejsza warto¶æ <code>count</code> i porównuje j± z zerem (operacja atomowa). Je¿eli nowa warto¶æ <code>count</code> jest wiêksza b±d¼ równa zero, to procesowi uda³o siê przej¶æ pod semaforem i zaj±æ zasób, w przeciwnym wypadku proces zmienia swój stan na TASK_UNINTERRUPTIBLE oraz wstawia  siê do kolejki <code>wait</code> - procesów czekaj±cych na zasób (funkcja <code>add_wait_exclusive()</code> - analogiczna ochrona jak w <code>wake_up()</code>, przy wykonywaniu tej funkcji). Nastêpnie proces wy³±cza przerwania (makro <code>spin_lock_irq()</code>)  i zwiêksza warto¶æ <code>sleepers</code>. Zaczyna wykonywaæ pêtlê. Atomowo zwiêksza <code>count</code> o <code>(sleepers - 1)</code> (makro <code>atomic_add_negative()</code>) i sprawdza czy warto¶æ <code>count</code> jest wiêksza b±d¼ równa zero. Je¶li tak, to mo¿e pobraæ zasób. Ustawia <code>sleepers</code> na 0 (¿eby zablokowaæ inne procesy), wychodzi z pêtli, odblokowuje przerwania (makro <code>spin_unlock_irq()</code>), usuwa siê z kolejki <code>wait</code> (funkcja <code>remove_wait_queue()</code>), zmienia stan na TASK_RUNNING i budzi pierwszy proces z kolejki <code>wait</code> funkcj± <code>wake_up()</code>. Je¶li <code>count &lt; 0</code>, to musi zasn±æ. Ustawia <code>sleepers</code> na 1, odblokowuje przerwania i wywo³uje funkcje <code>schedule()</code>, która go usypia (wyw³aszcza).  Po obudzeniu powtarza pêtlê a¿ do skutku.</p>
<pre>
void down(struct semaphore *sem)
{
    /*  Sekcja  krytyczna */
    sem-&gt;count--;
    if  (sem-&gt;count &lt; 0)  /* wpp. uda³o siê przej¶æ pod  semaforem */
    {
        /* Koniec sekcji */

        Zmieñ stan procesu na TASK_UNINTERRUPTIBLE;

        Wstaw proces do  kolejki oczekiwania semafora. /* add_wait_queue_exclusive() */

        Wy³±czenie  przerwañ /* spin_lock_irq() */
        sem-&gt;sleepers++;
  
        for (;;){
         
            int sleepers = sem-&gt;sleepers;
            if ((sem-&gt;count += sleepers - 1) &gt;= 0)/*!atomic_add_negative(sleepers-1, sem-&gt;count)*/
            {							  /* kto¶ podniós³ semafor */
                sem-&gt;sleepers = 0;
                break;  /* mo¿emy pobraæ zasób*/
            }

            sem-&gt;sleepers = 1;
            W³±czenie przerwañ /* spin_unlock_irq() */

            schedule(); /* proces zostaje u¶piony */

            Zmieñ stan procesu na TASK_UNINTERRUPTIBLE

            Wy³±czenie  przerwañ

        } /* for */
   
        W³±czenie przerwañ
  
        Usuñ proces z  kolejki oczekiwania semafora /* remove_wait_queue() */

        Zmieñ stan procesu na TASK_RUNNING

        Wstaw pierwszy (je¶li jest) proces z  kolejki oczekiwania semafora
        do kolejki procesów gotowych. /* wake_up() - budzenie procesu */
    }
}
</pre>
        <br><br>
        
<!-- prze³±czanie kontekstu (H¦) -->
        <hr noshade>
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#switch" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Huber ¦led¼
                </td>
            </tr>
        </table>
        <a name="switch"><h2>Prze³±czanie kontekstu</h2>
        <p>W sk³ad kontekstu procesu wchodz±: zawarto¶æ rejestrów procesora i przestrzeni adresowej procesu oraz struktury j±dra zwi±zane z danym procesem. Prze³±czanie  kontekstu polega na zamianie aktualnie wykonuj±cego siê procesu.<br><br>
        Sytuacje w jakich dochodzi do prze³±czania kontekstu to:</p>
        <ul>
            <li>pojawienie siê procesu o priorytecie wy¿szym ni¿ priorytet bie¿±cego procesu
            <li>za¶niêcie procesu w oczekiwaniu na jakie¶ zdarzenie 
            <li>wykorzystanie przez bie¿±cy proces przydzielonego mu kwantu czasu procesora
            <li>dobrowolna rezygnacja z procesora (wywo³anie funkcji <code>sched_yield()</code>)
            <li>zakoñczenie dzia³ania procesu
        </ul>
        <p>Z ka¿dym procesorem w systemie  jest zwi±zana specjalna struktura TSS, okre¶lana mianem segmentu stanu zadania. W tej strukturze system przechowuje kontekst aktualnie dzia³aj±cego procesu.<br><br>
        W TSS przechowywane s± nastêpuj±ce dane obecnie dzia³aj±cego procesu:</p>
        <ul>
            <li>adresy stosów  dla poziomów pracy procesora (pola esp0, ss0 , esp1, ss1, esp2, ss2)
            <li>rejestry ogólnego przeznaczenia (pola eax, ebx, ecx, edx)
            <li>rejestry indeksowe (pola esi, edi)
            <li>rejestry segmentowe(ds,es,fs,gs)
            <li>aktualny stos(ss,esp,ebp)
            <li>adres kolejnej instrukcji (cs, eip)
            <li>flagi(eflags)
            <li>mapa bitowa dostêpnych portów we/wy
        </ul>
        <p>W deskryptorze procesu jest pole <code>thread</code> typu <code>thread_struct</code>, w którym znajduj± siê informacje o stanie tego procesu  m.in. thread.esp0, esp, eip, fs, gs  o znaczeniu analogicznym jak odpowiednie pola w TSS.</p>

<!-- makro switch_to (H¦) -->
        <hr noshade size="1">
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#switch_to" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Huber ¦led¼
                </td>
            </tr>
        </table>
        <a name="switch_to"><h4>Makro switch_to</h4>
        <p>Makro <code>switch_to()</code> [<a class="path">Linux/include/asm-i386/system.h</a>] wykonuje prze³±czenie procesów. U¿ywa trzech parametrów oznaczonych jako <code>prev</code>, <code>next</code> i <code>last</code>. <code>prev</code> jest wska¼nikiem do deskryptora procesu, który ma byæ prze³±czony do t³a, a <code>next</code> jest wska¼nikiem do deskryptora procesu, który ma byæ wykonywany przez procesor. Makro to jest wywo³ywane przez funkcjê <code>schedule()</code>.<br><br>
        Jak dzia³a to makro?</p>
        <ul>
            <li>zapisuje na stosie bie¿±cego procesu rejestry ESI, EDI, EBP
            <li>prze³±cza stosy. W polu <code>prev-&gt;thread.esp</code> zapisywana jest bie¿±ca warto¶æ rejestru ESP, natomiast  z <code>next-&gt;thread.esp</code> jest odtwarzana  warto¶æ tego rejestru,  wskazuj±ca na szczyt stosu procesu <code>next</code> w segmencie danych j±dra. W tym momencie j±dro dzia³a na stosie j±dra <code>next</code>, tak wiêc tutaj nastêpuje prze³±czenie kontekstu
            <li>w <code>prev-&gt;thread.eip</code> jest zapisywany adres procedury, która powoduje odtworzenie ze stosu umieszczonych tam warto¶ci rejestrów  ESI, EDI oraz EBP.
            <li>nastêpnie jest przywracana warto¶æ EIP z <code>next-&gt;thread.eip</code>. Je¿eli proces <code>next</code> nie by³ jeszcze usypiany to w tym polu bêdzie adres etykiety <code>ret_from_fork</code>, której adres jest zapisywany w <code>thread.eip</code> procesu zaraz po jego utworzeniu przez funkcje systemow± <code>fork()</code>.
            <li>wywo³anie funkcji <code>__switch_to(prev, next)</code> [<a class="path">Linux/i386/kernel/process.c</a>], która koñczy prze³±czanie kontekstu.
        </ul>
        <p>Jak dzia³a <code>__switch_to()</code>?</p>
        <ul>
            <li>zapisuje stan koprocesora matematycznego.
            <li>za³adowuje rejestr esp0 z <code>next-&gt;thread.esp0</code>
            <li>zapamiêtuje rejestry FS i GS w <code>prev.thread</code>
            <li>za³adowuje nowe warto¶ci rejestrów FS i GS z <code>next-&gt;thread</code>
            <li>sprawdza czy proces wykonuje  siê w trybie <code>debug</code> i je¿eli tak, to ³adowane  s± rejestry <code>debugregs</code>
            <li>ustawiana jest odpowiednia mapa we/wy
        </ul>
        <p>Teraz j±dro dzia³a ju¿ w kontek¶cie nowego procesu.
        Po powrocie ze <code>__switch_to()</code> makro switch_to odtwarza warto¶ci rejestrów ESI, EDI, EBP.</p>

<!-- algorytm exec (H¦) -->
        <hr noshade>
        <table border="0" width="100%">
            <tr>
                <td>
                    <a href="#toc" class="totoc">spis tre¶ci</a> | <a href="#exec" class="totoc">=&gt;</a>
                </td>
                <td class="sig">
                    Huber ¦led¼
                </td>
            </tr>
        </table>
        <a name="exec"><h2>Algorytm exec</h2>
        <p>Zadaniem tego algorytmu jest zast±pienie zawarto¶ci pamiêci procesu przez nowy program. Algorytm ten za³adowuje plik binarny do pamiêci i rozpoczyna jego wywo³anie, zastêpuj±c segment kodu, danych i stosu. W szczególno¶ci  je¶li procesowi powiedzie siê wywo³anie funkcji exec, to nie  tworzy siê nowy proces, tylko ten sam proces dzia³a dalej jednak ma ju¿ inny kod  oraz podmieniony segment danych i stosu.  Nie zmienia mu siê PID, dziedziczy wszystkie deskryptory  otwartych plików, które nie maj± opcji zamykania podczas exec oraz zostaje przywrócona standardowa obs³uga sygna³ów, chocia¿ sygna³y ignorowane przed wywo³aniem funkcji nadal bêd± ignorowane.<br><br>
        Jednak¿e algorytm exec wykorzystuje tylko ju¿ istniej±ce funkcje w systemie, s³u¿±ce do ³adownia plików binarnych. <br><br>
        Na pocz±tku zostaje wywo³ana funkcja <code>execve()</code>. [<a class="path">Linux/include/asm-i386/unistd.h</a>]<br>
        Deklaracja:<br>
        <code>static inline int execve(const char *file, char **argv,  char **envp);</code><br>
        gdzie:<br>
        <code>file</code> - nazwa programu do wykonania<br>
        <code>argv</code> - tablica zawieraj±ca argumenty  dla programu<br>
        <code>envp</code> - tablica zawieraj±ca ustawione zmienne ¶rodowiskowe<br><br>
        Funkcja ta wywo³uje przerwanie (<code>SYSCALL_VECTOR</code>) i przekazuje swoje parametry do procedury obs³ugi tego przerwania (<code>sys_call</code>). Z kolei ta procedura uruchamia funkcjê <code>sys_execve()</code> [<a class="path">Linux/arch/i386/kernel/process.c</a>], której parametrem jest struktura zawieraj±ca stan rejestrów procesora (<code>struct pt_regs</code> [<a class="path">Linux/include/asm-i386/ptrace.h</a>]).<br><br>
        Funkcja <code>sys_execve()</code> sprawdza, czy podany plik jest wykonywalny i czy nie jest katalogiem lub urz±dzeniem - je¶li tak zwraca b³±d i funkcja <code>exec()</code> na zmiennej <code>errno</code> zapisuje kod b³êdu.<br>
        W przeciwnym wypadku zostaje wywo³ana funkcja <code>do_execve()</code> z parametrami takimi jak <code>execve()</code>, oraz dodatkowo z parametrem z <code>sys_execve()</code>.<br><br>
        Struktura <code>struct linux_binprm</code> [<a class="path">Linux/include/linux/binfmts.h</a>] zawiera m.in. pola:</p>
        <ul>
            <li><code>char buf[128]</code> - tu przechowywanych jest 128 pierwszych znaków ³adowanego programu
            <li><code>int e_uid, e_gid</code> - zawieraj± odpowiednio, efektywny identyfikator u¿ytkownika oraz identyfikator grupy procesu uruchamiaj±cego.
        </ul>
        <p>i jest wykorzystywana przez <code>do_execve()</code>.<br><br>
        Funkcja <code>do_execve()</code> wykonuje nastêpuj±ce operacje:
        <ol>
            <li>Statycznie alokuje strukturê danych <code>linux_binprm</code>, która zostanie wype³niona danymi, dotycz±cymi nowego pliku wykonywalnego
            <li>Wywo³uje funkcjê <code>open_exec()</code> w celu pobrania obiektu pozycji katalogu. W przypadku niepowodzenia zwraca odpowiedni kod b³êdu.
            <li>Wywo³uje funkcjê <code>prepare_binprm()</code>,po to by wype³niæ  strukturê <code>linux_binprm</code>. Funkcja ta wykonuje operacje:
                <ul>
                    <li>Sprawdza, czy prawa pliku umo¿liwiaj± jego wykonanie, wpp. zwraca kod b³êdu.
                    <li>Sprawdza, czy plik jest w³a¶nie zapisywany, je¿eli tak zwraca kod b³êdu.
                    <li>Inicjuje pola <code>e_uid</code> i <code>e_gid</code> struktury <code>linux_binprm</code>, bior±c pod uwagê warto¶ci flag <code>setuid</code> i <code>setgid</code> pliku wykonywalnego. Pola te reprezentuj± odpowiednie identyfikatory efektywnego u¿ytkownika i grupy.
                    <li>Wype³nia pole <code>buf</code> struktury <code>linux_binprm</code> pierwszymi 128 znakami pliku wykonywalnego. Bajty te zawieraj± informacje umo¿liwiaj±ce rozpoznanie formatu pliku wykonywalnego.
                </ul>
            <li>Kopiuje ¶cie¿kê dostêpu argumentu linii poleceñ i zmienne ¶rodowiskowe do jednego lub wiêcej nowo zaalokowanych bloków stronicowych. 
            <li>Wywo³uje funkcjê <code>search_binary_handler()</code>, która zajmuje siê w³a¶ciwym uruchamianiem programu. Na pocz±tku pobiera wska¼nik do pocz±tku listy dostêpnych formatów dziêki makru <code>formats</code>. Nastêpnie dla ka¿dego formatu próbuje zastosowaæ jego funkcjê s³u¿±c± do ³adowania programu (<code>load_binary()</code>), przekazuj±c jej  strukturê danych <code>linux_binprm</code>. Przeszukiwanie listy <code>formats</code> koñczy siê gdy tylko jaka¶ funkcja <code>load_binary()</code> potwierdzi format wykonywalny pliku.
            <li>Je¿eli format pliku wykonywalnego nie znajduje siê na li¶cie <code>formats</code>, zwalnia wszystkie zaalokowane bloki stronicowe i zwraca kod b³êdu. Linux nie mo¿e rozpoznaæ formatu pliku wykonywalnego.
            <li>W przeciwnym wypadku ustawia flagê w strukturze procesu mówi±c± o tym, ¿e uda³o siê wykonaæ <code>exec()</code> i zwraca kod zwrócony przez funkcjê <code>load_binary()</code>, zwi±zan± z formatem pliku wykonywalnego.
        </ul><br><br>
        <p>Niektóre b³êdy jakie mo¿e zg³osiæ funkcja <code>exec()</code>:</p>
        <table border="0" cellpadding="1" cellspacing="0">
            <tr><td width="40">&nbsp;</td><td><code>EACCES</code></td><td width="20">&nbsp;</td><td>- zabroniony dostêp do pliku</td></tr>
            <tr><td width="40">&nbsp;</td><td><code>ENOMEM</code></td><td width="20">&nbsp;</td><td>- nowy proces wymaga zbyt du¿o pamiêci</td></tr>
            <tr><td width="40">&nbsp;</td><td><code>EAGAIN</code></td><td width="20">&nbsp;</td><td>- ilo¶æ pamiêci podczas operacji we/wy jest niewystarczaj±ca</td></tr>
            <tr><td width="40">&nbsp;</td><td><code>ENOENT</code></td><td width="20">&nbsp;</td><td>- b³êdna ¶cie¿ka dostêpu do pliku</td></tr>
        </table><br>
        <br><br>
        
    </body>
</html>

