\documentclass[12pt,a4paper,oneside]{article}
\RequirePackage[T1]{fontenc}
\RequirePackage{times}
\RequirePackage[latin2]{inputenc}
\RequirePackage[polish]{babel}
\RequirePackage{a4wide}
\RequirePackage{longtable}
\RequirePackage{multicol}
\RequirePackage{url}
\usepackage{graphics}


\begin{document}

\begin{center}
{\Huge SOOPL --- Simple, Object-Oriented Programming Language}\\\ \\\ 
{\tt http://rainbow.mimuw.edu.pl/\~{}mm/hp/soopl}
\end{center}

%\large{
\section{Jêzyk}

\subsection{Za³o¿enia}
\begin{itemize}
\item oparty na Smalltalku
\item jêzyk czysto obiektowy, z minimalnym zestawem instrukcji w rodzaju pêtli, instrukcji warunkowych itp.
\item oparty o pojêcia obiektu i komunikatu\\
{\footnotesize tj. obiekty przesy³aj± miêdzy sob± komunikaty}
\item ma³a sk³adnia --- w zasadzie tylko wysy³anie komunikatów oraz niezbêdne instrukcje (zwrot warto¶ci, przypisanie)
\item funkcjonalno¶æ zaszyta w bibliotece klas\\
{\footnotesize naturalna konsekwencja przyjêtych ograniczeñ sk³adniowych --- je¶li nie mo¿na zrealizowaæ pêtli lub instrukcji warunkowej poprzez konstrukcje samego jêzyka, trzeba dostarczyæ mechanizmów pozwalaj±cych osi±gn±æ to w inny sposób; (z pêtl± akurat nie ma wiêkszego problemu, bo mo¿na wykorzystaæ rekursjê)}
\item dynamiczna kontrola typów
\item dynamiczna dyspozycja (wi±zanie metod)\\
{\footnotesize brak kontroli poprawno¶ci komunikatów na etapie kompilacji; jak obiekt nie rozumie komunikatu, to bêdzie b³±d w czasie wykonania}
\item bloki, wykonywane w kontek¶cie z miejsca deklaracji\\
{\footnotesize jak w Smalltalku; ciekawy efekt: mo¿liwo¶æ przesy³ania bloku jako argumentu komunikatu, wygodne do wykonywania operacji na elementach kolekcji (wymaga bloku z parametrem); ogólnie: bardzo ciekawy i potê¿ny mechanizm}
\end{itemize}

\subsection{Przyjête rozwi±zania i ograniczenia}
\begin{itemize}
\item bloki bezparametrowe
\item typy: klasa, obiekt, blok, typ pierwotny (liczby naturalne)
\item statyczna klasyfikacja (wi±zanie obiektu do klasy)
\end{itemize}
{\footnotesize rozwi±zania te mia³y u³atwiæ implementacjê; z wiêkszo¶ci z nich mo¿na zrezygnowaæ stosunkowo niewielkim nak³adem pracy}

\subsection{Elementy sk³adni}
{\footnotesize prezentowane po to, aby daæ pojêcie o sile wyrazu jêzyka}
\subsubsection{Wyra¿enia}
\begin{itemize}
\item sta³a (nieujemna liczba ca³kowita)
\item identyfikator
\item konstrukcja obiektu:\\ {\tt new} {\it identyfikatorKlasy}
\item deklaracja bloku:\\ {\tt [} {\it \{instrukcja1... instrukcjaN\}} {\tt ]}
\item komunikat:\\ {\tt send} {\it wyra¿enie} {\tt message} {\it identyfikatorKomunikatu \{} {\tt with} {\it argument1... argumentN\{}{\tt .}{\it \}\}}\\
{\footnotesize {\it wyra¿enie} ma siê ewaluowaæ do klasy/obiektu docelowego --- ze wzglêdu na dynamiczn± kontrolê typów b³edy s± wykrywane w momencie wykonania}
\end{itemize}
\subsubsection{Instrukcje}
\begin{itemize}
\item przypisanie:\\ {\tt assign} {\it identyfikator} {\it wyra¿enie}
\item ewaluacja:\\ {\tt eval} {\it wyra¿enie}\\
{\footnotesize {\it wyra¿enie} jest wyliczane a jego warto¶æ ignorowana}
\item wykonanie bloku:\\ {\tt exec} {\it wyra¿enie}\\
{\footnotesize {\it wyra¿enie} ma siê ewaluowaæ do bloku --- znów b³êdy wykrywane na etapie wykonania}
\item zwrot warto¶ci:\\ {\tt return} {\it wyra¿enie}
\end{itemize}


\subsection{Biblioteka klas}
\begin{itemize}
\item {\bf Root} --- klasa bazowa, po niej dziedzicz± wszystkie klasy w SOOPL\\
{\footnotesize nie udostêpnia ¿adnych pól ani metod}
\item {\bf Boolean} --- reprezentuje warto¶ci boolowskie\\
ciekawsze metody: {\tt and}, {\tt or}, {\tt ifElse}\\
{\footnotesize pozwala na wykonanie warunkowe --- do ifElse przesy³a siê dwie rzeczy; je¶li obiekt ma warto¶æ true zwracana jest pierwsza, wpp. druga}
\item {\bf Integer} --- reprezentuje liczby ca³kowite\\
ciekawsze metody: {\tt add}, {\tt equals}, {\tt multiply}
{\footnotesize opakowanie dla typu pierwotnego}
\item {\bf TextIO} --- obs³uguje standardowe wej¶cie/wyj¶cie\\
ciekawsze metody: {\tt outputInt}, {\tt outputEOL}\\
{\footnotesize pozwala na wypisywanie liczb na ekran}
\end{itemize}


\subsection{Przyk³adowy program}
{\footnotesize nie jest obiektowy --- ma jedynie pokazaæ w jaki sposób wykorzystuje siê niektóre w³asno¶ci sk³adni jêzyka}\\
Program wypisuj±cy na ekran $n$ pierwszych liczb Fibonacciego:
\begin{verbatim}
class Fibonacci extends Root
  objvars
  classvars
  classmethod fib args p1 p2 cit tot 
                       wrP1 wrCit newV b is
    assign wrP1 new Integer
    assign wrCit new Integer
    assign newV new Integer
    eval send wrP1 message setValue with p1 
    eval send wrCit message setValue with cit 
    eval send newV message setValue 
         with send wrP1 message add with p2 
    eval send send TextIO message outputInt 
              with send newV message getValue 
         message outputEOL 
    assign b new Boolean 
    eval send b message setValue 
         with send wrCit message equals with tot
    exec send b message ifElse with [ 
      return self 
    ] [ 
      eval send self message fib 
           with p2 
                send newV message getValue 
                send wrCit message add with 1. 
                tot 
    ] 
   
  classmethod run args it is 
    eval send self message fib with 0 1 1 it 
	    
init send Fibonacci message run with 30.
\end{verbatim}

\subsection{Mo¿liwe rozszerzenia}
{\footnotesize ogólnie: rezygnacja z przyjêtych ograniczeñ}
\begin{itemize}
\item rezygnacja z typu pierwotnego --- automatyczne opakowywanie ({\it boxing})\\
{\footnotesize korzystanie z typu pierwotnego jest ogólnie nieeleganckie, czêsto koduje on warto¶ci które powinny byæ widoczne wy³±cznie jako obiekty (np. warto¶ci boolowskie --- widaæ to w przyk³adowym programie) i programista musi z tego explicite korzystaæ}
\item rezygnacja z typu blokowego\\
{\footnotesize znów: automatyczne tworzenie obiektów typu Block; pozwoli na zmniejszenie sk³adni --- nie bedzie potrzebna instrukcja {\tt exec}}
\item bloki z parametrami
\end{itemize}



\section{Program}

\subsection{Specyfikacja}
Podstawa dla interpretera: semantyka denotacyjna jêzyka (oparta o kontynuacje).\\
{\footnotesize dostêpna na www; dygresja: w ogóle semantyki dla jêzyków obiektowych s± pewnym problemem, bo nie ma w tej chwili ¿adnego kanonu, wed³ug którego semantyki takie siê tworzy; wynika to z ró¿nic w modelu obiektu pomiêdzy konkretnymi jêzykami oraz z k³opotów przy czytelnym przedstawianiu takich zagadnieñ jak wspó³bie¿no¶æ, dziedziczenie (a szczególnie wielodziedziczenie), to¿samo¶æ obiektów. (na uniwersytecie w Monachium istnieje zespó³ opracowuj±cy ogólne podstawy dla konstruowania semantyk jêzyków obiektowych; staraj± siê miêdzy innymi opracowaæ pe³n± (uwzglêdniaj±c± wielow±tkowo¶æ) semantykê Javy)\\
kontynuacje stosuje siê w praktyce --- np. Python jest oparty na kontynuacjach}\\
{\bf wej¶cie:} stan, ¶rodowisko, tekst programu;\\
{\bf wyj¶cie:} stan i ¶rodowisko, zmodyfikowane zgodnie z semantyk± SOOPL.

\subsection{Etapy projektowania}
\subsubsection{Warstwa procesów}
obrazek
%obrazek
\subsubsection{Warstwa danych}
obrazek\\
%obrazek
{\footnotesize jako podstawowe rozbicie przyj±³em procesy, one za¶ korzystaj± z warstwy danych. Dodatkowo wprowadzi³em modu³ Class library i rozbi³em Semantic domains na podmodu³y Memory, Environment i Utilities --- to pozwala na ³atw± wymianê struktur u¿ywanych do przechowywania stanu programu i ¶rodowiska na bardziej efektywne (obecnie s± to po prostu funkcje)}

\subsection{Hierarchia modu³ów}
obrazek\\
% obrazek
{\footnotesize Interpreter nie stanowi przepisanej s³owo w s³owo semantyki --- wprowadzone zosta³y np. wyj±tki, pozwalaj±ce okre¶liæ w którym miejscu programu wyst±pi³ b³±d}

\subsection{Przyk³ady kodu}
\subsubsection{Aksjomat}
\begin{verbatim}
val subst: (''a -> 'b) -> 'b -> ''a -> (''a -> 'b)
axiom forall f =>
          forall v => 
              forall a =>
                  (subst f v a a = v) andalso
                  (forall b => (b <> a) implies (subst f v a b = f b))
\end{verbatim}
\subsubsection{Biblioteka klas}
\begin{verbatim}
val andMethod = 
  mkDVMethod(
    mkMethod(
      fn t: Loc =>
        fn mkEnv(lr): Env =>
          fn mkCExp(ce): CExp =>
            mkCSt(
              fn mkS(s, ml): S =>
                let val mkDVLoc(l1) = lr (mkIde "val")
                    val mkDVLoc(l2) = lr (mkIde "op")
                    val mkSVPrimitive(mkPrimitive(i1)) = s l1
                    val mkSVPrimitive(mkPrimitive(i2)) = s l2
                    val mkCSt(cs) = 
                    ce (mkEVPrimitive(
                      mkPrimitive(
                        if i1 <> 0 andalso i2 <> 0 then 1 
                        else 0)))
                in cs (mkS(s, ml))
                end)),
    [mkIde("op")]);
val ifElseMethod = mkDVMethod(...);
val orMethod = mkDVMethod(...);
val getValueMethod = mkDVMethod(...);
val setValueMethod = mkDVMethod(...);
val booleanClass = 
  mkClass(mkLoc(0),
          emptyEnv,
          emptyEnv,
          [mkIde("val")],
          mkEnv(fn id: Ide => 
                  case id of
                      mkIde("and") => andMethod
                    | mkIde("ifElse") => ifElseMethod
                    | mkIde("or") => orMethod
                    | mkIde("getValue") => getValueMethod
                    | mkIde("setValue") => setValueMethod
                    | _ => unboundIde id));
\end{verbatim}

\subsection{Mo¿liwe rozszerzenia i usprawnienia}
\begin{itemize}
\item lepsze zarz±dzanie pamiêci± (Modu³y {\it Memory} i {\it Environment}) --- efektywna struktura danych, automatyczne od¶miecanie itp.
\end{itemize}


%}

\end{document}

 